---
title: "AllSierras_Maps"
output: html_document
---
```{r include=FALSE}
library(tidyverse)
library(ggplot2)
library(dplyr)
library(dataRetrieval)
library(sf)
library(maps)
library(sp)
library(ncdf4)
library(sf)
library(sp)
library(lwgeom)
library(terra)
library(raster)
library(mapview)
library(tidyterra)
library(viridis)
library(MetBrewer)
library(stars)
library(data.table)
library(tigris)
library(patchwork)
library(car)
library(multcomp)
library(exactextractr)
library(scales)
library(ggrepel)
```

#Input Files (all together)
```{r}
AllSierras_DamCapacity <- readRDS("AllSierras_DamCapacity_volume.rds")
background <- readRDS("background.rds")
#PADUS <- readRDS("PADUS.rds")
WatershedBoundaries <- readRDS("WatershedBoundaries.rds")
#PADUS_clip <- readRDS("PADUS_clip.rds")
#PADUS_Gap12 <- readRDS("PADUS_Gap12.rds")
#DamCap_GAP12 <- readRDS("DamCap_GAP12.rds")
#TNC_DamCapacity <- readRDS("TNC_DamCapacity.rds")
contFireRisk <- readRDS("contFireRisk.rds")
#contFireRisk <- readRDS("contFireRisk.rds")
#watershedsPoly <- readRDS("watershedsPoly.rds")
#watersheds <- readRDS("watersheds.rds")
intermittent <- readRDS("intermittent.rds")

```




```{r}
sum(AllSierras_DamCapacity$volume)
summary(AllSierras_DamCapacity$volume)
hist(AllSierras_DamCapacity$volume)
sum(WatershedBoundaries$area_km2_Streamshq)
summary(WatershedBoundaries$area_km2_Streamshq)

```
##Intermittent
```{r}
# Read in the shapefile with st_read()
intermittent <- st_read("C:/Users/jessie_moravek/Desktop/SierraNevadaBeavers/AllSierras_DamCapacity_Intermittent5.shp")

#remove unneeded shapefiles
file.remove(list.files(pattern = "AllSierras_DamCapacity_Intermittent*",recursive = F))

# Read in shapefile from previously imported shapefile
intermittent <- readRDS("intermittent.rds")

crs(AllSierras_DamCapacity) ==crs(intermittent)

#Project to wkt (NASA projection)
intermittent <- st_transform(intermittent, 3310)

saveRDS(intermittent,"intermittent.rds")
```

##Background
```{r eval=FALSE, include=FALSE}
background <- states(cb = FALSE)

background <- st_make_valid(background) %>%
  dplyr::mutate(valid =st_is_valid(background)) %>% 
  dplyr::filter(valid=="TRUE") 
#^Millie's validation code...use later

background <- background %>% filter(NAME == "California" | NAME == "Nevada")
background <- st_transform(background, 3310)
box <- st_bbox(AllSierras_DamCapacity)
background_crop <- st_crop(background, box)

saveRDS(background,"background.rds")
```


##Watershed Boundaries Map

```{r}
palette_new <- colorRampPalette(colors = c("#ff0000", "#ffa500", "#ffff00", "#00FF50", "#4900FF"))(5)

w <- ggplot() +
    geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = WatershedBoundaries, fill = "#b0b0b0", lwd = 0.1, alpha = 0.5 ) +
    scale_color_manual(values=palette_new)+
    theme_minimal()+
    ggtitle(expression(paste("Watershed Boundaries"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    #theme(element_text(size=10),legend.position = c(.15,.2))+
    #labs(color = "dams/km", size=10)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.border = element_rect(colour = "black", fill=NA))

```

##Current Dam Capacity Map
```{r}
#scales::show_col(palette_new)

c <- ggplot() +
    #geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = transform(AllSierras_DamCapacity, DamCapacity=cut(oCC_EX, breaks = c(0,.1,2,5,15,40), include.lowest=T)),aes(color = DamCapacity)) +
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
    scale_color_manual(values=palette_new,
                        labels = c("0", "1-2", "2-5", "5-15", "15-40"))+
    theme_minimal()+
    ggtitle(expression(paste("Current Dam Capacity"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    theme(legend.text = element_text(size=8),
          legend.title = element_text(size = 8),
          legend.position = c(.2,.20))+
    #theme(element_text(size=10),legend.position = c(.15,.2))+
    labs(color = "dams/km", size=10)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.border = element_rect(colour = "black", fill=NA))

```

##Historical Dam Capacity Map
```{r}
h <- ggplot() +
    #geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = transform(AllSierras_DamCapacity, DamCapacity=cut(oCC_HPE, breaks = c(0,.1,2,5,15,40), include.lowest=T)),aes(color = DamCapacity)) +
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
    scale_color_manual(values=palette_new,
                        labels = c("0", "1-2", "2-5", "5-15", "15-40"))+
    theme_minimal()+
    ggtitle(expression(paste("Historical Dam Capacity"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    theme(legend.text = element_text(size=8),
          legend.title = element_text(size = 8),
          legend.position = c(.2,.20))+
    #theme(element_text(size=10),legend.position = c(.15,.2))+
    labs(color = "dams/km", size=10)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.border = element_rect(colour = "black", fill=NA))

```

#Calculate Historical Percent Remaining
```{r}
AllSierras_DamCapacity$mCC_EXvHPE <- AllSierras_DamCapacity$oCC_EX/AllSierras_DamCapacity$oCC_HPE
#When doing this division, sometimes we get 0/0 = Inf, especially in areas that are slope limited. In one way of looking at it, these values should be converted to 1, since dam capacity stayed the same from historic to current. However we converted them to NA? 
AllSierras_DamCapacity$mCC_EXvHPE[!is.finite(AllSierras_DamCapacity$mCC_EXvHPE)] <- NA
```

##Percent Remaining Map
```{r}
r <- ggplot() +
    #geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = transform(AllSierras_DamCapacity, DamCapacity=cut(mCC_EXvHPE, breaks = c(0,.25,.5,.75,1,70), include.lowest=T)),aes(color = DamCapacity)) +
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
    scale_color_manual(values=palette_new)+
    theme_minimal()+
    ggtitle(expression(paste("Percent Dam Capacity Remaining"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    #theme(element_text(size=10),legend.position = c(.15,.2))+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    labs(color = "dams/km", size=10)+
    theme(panel.border = element_rect(colour = "black", fill=NA))

```

#Change in veg suitability
```{r}
AllSierras_DamCapacity$VegChange100 <-  AllSierras_DamCapacity$iVeg100EX - AllSierras_DamCapacity$iVeg100Hpe 

```

##Change in veg suitability map
```{r}

veg <- ggplot() +
    geom_sf(data = AllSierras_DamCapacity, aes(color = VegChange100)) +
    scale_color_gradient2(low = "red", mid = "white", high = "blue", midpoint = 0, na.value = "grey70")+
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
    xlab(NULL)+
    ylab(NULL)+
    ggtitle(expression(paste("Vegetation Change"))) + 
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5))+
    theme(legend.text = element_text(size=8),
          legend.title = element_text(size = 8),
          legend.position = c(.2,.20))+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    labs(color = "Vegetation\nChange")+
    theme(panel.border = element_rect(colour = "black", fill=NA)) 
```
#Intermittent
##Current intermittent volume calculation
```{r}
for (i in intermittent){ #for each stream segment in the BRAT model output shapefile
  damCt <- intermittent$mCC_EX_CT #number of beaver dams per segment (calculated based on dam density and segment length as the column mCC_EX_CT in the attribute table)
  slope <- intermittent$iGeo_Slope #meters
  da <- intermittent$iGeo_DA #m2
  width <- ifelse(da < 4.95,2.18*(da)^0.191,
                  ifelse(da >= 4.95 & da < 377,1.41*(da)^0.462,7.18*(da)^0.183)) #based on Scamardo et al. 2022
  height <- 1 #assume all beaver dams are 1m tall
  length <- height/slope #trigonometry: slope = rise/run, so run = rise/slope
  maxLength<- (intermittent$iGeo_Len/damCt) #set a maximum length so that we can change volume calculations if there are so many dams that they all run together
  volume <- ifelse(length < maxLength, 0.5*(height)*(width)*(length)*(damCt),(height)*(width)*(maxLength)*(damCt))
  surfaceArea <- ifelse(length < maxLength, (width)*(length)*(damCt),(width)*(maxLength)*(damCt))
  intermittent$width <- width
  intermittent$volume <- volume #m3
  intermittent$surfaceArea <- surfaceArea #m2
} 
```

##Historical intermittent volume calculation
```{r}
for (i in intermittent){ #for each stream segment in the BRAT model output shapefile
  damCt <- intermittent$mCC_HPE_CT #number of beaver dams per segment (calculated based on dam density and segment length as the column mCC_HPE_CT in the attribute table)
  slope <- intermittent$iGeo_Slope #meters
  da <- intermittent$iGeo_DA #m2
  width <- ifelse(da < 4.95,2.18*(da)^0.191,
                  ifelse(da >= 4.95 & da < 377,1.41*(da)^0.462,7.18*(da)^0.183)) #based on Scamardo et al. 2022
  height <- 1 #assume all beaver dams are 1m tall
  length <- height/slope #trigonometry: slope = rise/run, so run = rise/slope
  maxLength<- (intermittent$iGeo_Len/damCt) #set a maximum length so that we can change volume calculations if there are so many dams that they all run together
  volumeHist <- ifelse(length < maxLength, 0.5*(height)*(width)*(length)*(damCt),(height)*(width)*(maxLength)*(damCt))
  surfaceAreaHist <- ifelse(length < maxLength, (width)*(length)*(damCt),(width)*(maxLength)*(damCt))
  intermittent$width <- width
  intermittent$volumeHist <- volumeHist #m3
  intermittent$surfaceAreaHist <- surfaceAreaHist #m2
} 

```

##Current Intermittent Dam Capacity Map
```{r}
#scales::show_col(palette_new)

ci <- ggplot() +
    #geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = transform(intermittent, DamCapacity=cut(oCC_EX, breaks = c(0,.1,2,5,15,40), include.lowest=T)),aes(color = DamCapacity)) +
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
    scale_color_manual(values=palette_new,
                        labels = c("0", "1-2", "2-5", "5-15", "15-40"))+
    theme_minimal()+
    ggtitle(expression(paste("Intermittent Stream Dam Capacity"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    theme(legend.text = element_text(size=8),
          legend.title = element_text(size = 8),
          legend.position = c(.2,.20))+
    #theme(element_text(size=10),legend.position = c(.15,.2))+
    labs(color = "dams/km", size=10)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.border = element_rect(colour = "black", fill=NA))

```

##Historical Intermittent Dam Capacity Map
```{r}
h <- ggplot() +
    #geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = transform(intermittent, DamCapacity=cut(oCC_HPE, breaks = c(0,.1,2,5,15,40), include.lowest=T)),aes(color = DamCapacity)) +
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
    scale_color_manual(values=palette_new,
                        labels = c("0", "1-2", "2-5", "5-15", "15-40"))+
    theme_minimal()+
    ggtitle(expression(paste("Historical Dam Capacity"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    theme(legend.text = element_text(size=8),
          legend.title = element_text(size = 8),
          legend.position = c(.2,.20))+
    #theme(element_text(size=10),legend.position = c(.15,.2))+
    labs(color = "dams/km", size=10)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.border = element_rect(colour = "black", fill=NA))

```

##combine intermittent with perennial network
```{r}
intermittent$flow <- "intermittent"
sum(intermittent$flow == "intermittent")
intermittent_selection <- intermittent[,c("geometry","flow")]

test <- st_join(AllSierras_DamCapacity, intermittent_selection, join= st_overlaps)
unique(test$flow)
sum(test$flow =="intermittent", na.rm=T)


test2 <- dplyr::distinct(test)

unique(st_is_valid(AllSierras_DamCapacity))
unique(st_is_valid(test2))



test$flow <- ifelse(is.na(test$flow), "perennial", test$flow)
unique(test$flow)

```
#percentages
```{r}
zero <- test %>% 
  filter(oCC_EX == 0) 

sum(zero$flow == "perennial")
sum(zero$flow == "intermittent")
```



#Change in volume
##Historical volume calculation
```{r}
for (i in AllSierras_DamCapacity){ #for each stream segment in the BRAT model output shapefile
  damCt <- AllSierras_DamCapacity$mCC_HPE_CT #number of beaver dams per segment (calculated based on dam density and segment length as the column mCC_HPE_CT in the attribute table)
  slope <- AllSierras_DamCapacity$iGeo_Slope #meters
  da <- AllSierras_DamCapacity$iGeo_DA #m2
  width <- ifelse(da < 4.95,2.18*(da)^0.191,
                  ifelse(da >= 4.95 & da < 377,1.41*(da)^0.462,7.18*(da)^0.183)) #based on Scamardo et al. 2022
  height <- 1 #assume all beaver dams are 1m tall
  length <- height/slope #trigonometry: slope = rise/run, so run = rise/slope
  maxLength<- (AllSierras_DamCapacity$iGeo_Len/damCt) #set a maximum length so that we can change volume calculations if there are so many dams that they all run together
  volumeHist <- ifelse(length < maxLength, 0.5*(height)*(width)*(length)*(damCt),(height)*(width)*(maxLength)*(damCt))
  surfaceAreaHist <- ifelse(length < maxLength, (width)*(length)*(damCt),(width)*(maxLength)*(damCt))
  AllSierras_DamCapacity$width <- width
  AllSierras_DamCapacity$volumeHist <- volumeHist #m3
  AllSierras_DamCapacity$surfaceAreaHist <- surfaceAreaHist #m2
} 

```

##Historical volume map
```{r}
hmap <- ggplot() +
    geom_sf(data = AllSierras_DamCapacity, aes(color = volumeHist)) +
    scale_color_viridis(discrete = FALSE, option = "plasma", na.value = "grey70")+
    xlab(NULL)+
    ylab(NULL)+
    ggtitle(expression(paste("Potential Water Storage (m3)"))) + 
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5)) +
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.border = element_rect(colour = "black", fill=NA))
```

##Current volume map
```{r}
currentVol <- ggplot() +
    geom_sf(data = AllSierras_DamCapacity, aes(color = volume)) +
    scale_color_viridis(discrete = FALSE, option = "plasma", na.value = "grey70")+
    xlab(NULL)+
    ylab(NULL)+
    ggtitle(expression(paste("Potential Water Storage (m3)"))) + 
    theme_minimal() +
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) 
```
##Volume Change
```{r}
AllSierras_DamCapacity$VolumeChange <-  AllSierras_DamCapacity$volume - AllSierras_DamCapacity$volumeHist

```
##Volume change map
```{r}
vol <- ggplot() +
    geom_sf(data = AllSierras_DamCapacity, aes(color = VolumeChange)) +
    scale_color_gradient2(low = "red", mid = "grey70", high = "blue", midpoint = 0, na.value = "grey70")+
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
    xlab(NULL)+
    ylab(NULL)+
    ggtitle(expression(paste("Change in Volume (m3)"))) + 
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    theme(legend.text = element_text(size=8),
          legend.title = element_text(size = 8),
          legend.position = c(.2,.20))+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    labs(color = "Volume\nChange (m3)")+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.border = element_rect(colour = "black", fill=NA))
```
###Map of watersheds + veg + volume
```{r}
layout <- "
AB
C#
"

r + veg + vol + 
  plot_layout(design = layout)

h+c+veg
```


##Normalizing volume
```{r}
AllSierras_DamCapacity$VolumePerKm <-  AllSierras_DamCapacity$volume/((AllSierras_DamCapacity$iGeo_Len)*0.001)

```
##Current volumePerKm map
```{r}
volperkm <- ggplot() +
    geom_sf(data = AllSierras_DamCapacity, aes(color = VolumePerKm)) +
    scale_color_viridis(discrete = FALSE, option = "plasma", na.value = "grey70")+
    xlab(NULL)+
    ylab(NULL)+
    ggtitle(expression(paste("Potential Water Storage (m3/km)"))) + 
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5))+
    theme(panel.border = element_rect(colour = "black", fill=NA)) 
```

#Apply volume to every watershed
```{r}
watersheds <- st_join(WatershedBoundaries,AllSierras_DamCapacity)
#watershedsPoly <- st_intersection(AllSierras_DamCapacity, WatershedBoundaries)
#saveRDS(watershedsPoly,"watershedsPoly.rds")
#saveRDS(watersheds,"watersheds.rds")

test <- watersheds %>%
    group_by(geometry) %>% 
    summarise(normVol = mean(VolumePerKm),
              totalVol = sum(volume),
              totalVolHist = sum(volumeHist),
              totalVolChange = sum(VolumeChange),
              totalBeavs = sum(mCC_EX_CT),
              avgBeavs = mean(oCC_EX),
              histChange = mean(mCC_EXvHPE, na.rm=T))

totalVol <- ggplot() +
  geom_sf(data = WatershedBoundaries) +
  geom_sf(data = test, aes(fill = totalVol), inherit.aes = FALSE) +
  scale_fill_viridis_c(option = "plasma") + 
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("Potential Water Storage (m3)"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
  theme(panel.border = element_rect(colour = "black", fill=NA))

normVol <- ggplot() +
  geom_sf(data = WatershedBoundaries) +
  geom_sf(data = test, aes(fill = normVol), inherit.aes = FALSE) +
  scale_fill_viridis_c(option = "plasma") + 
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("Normalized Potential Water Storage \n(m3/km)"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
  theme(panel.border = element_rect(colour = "black", fill=NA))


```

#Apply Dam Capacity to every watershed
```{r}
avgBeavs <- ggplot() +
  geom_sf(data = WatershedBoundaries) +
  geom_sf(data = test, aes(fill = avgBeavs), inherit.aes = FALSE) +
  scale_fill_viridis_c() + 
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("Average dams/km"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5))+
  theme(panel.border = element_rect(colour = "black", fill=NA))
```

#Watershed summary historical change
```{r}
histChange <- ggplot() +
  geom_sf(data = WatershedBoundaries) +
  geom_sf(data = test, aes(fill = histChange), inherit.aes = FALSE) +
  scale_fill_viridis_c(option = 'cividis') + 
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("% Dam Capacity Remaining (dams/km)"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5))+
  theme(panel.border = element_rect(colour = "black", fill=NA))
```

#Fire Risk Continuous
```{r}
#Read in the raster 
contFireRisk <- rast("C:/Users/jessie_moravek/Desktop/SierraNevadaBeavers/FireRisk/FireRisk_4.tif")
#plot(contFireRisk)
contFireRisk <- project(contFireRisk, crs(AllSierras_DamCapacity))
crs(contFireRisk) == crs(AllSierras_DamCapacity) #== crs(WatershedBoundaries)
wkt <- crs(contFireRisk)

#Crop
contFireRisk <- crop(contFireRisk, WatershedBoundaries)
contFireRisk <- mask(contFireRisk, WatershedBoundaries)
#plot(contFireRisk)

#save
saveRDS(contFireRisk,"contFireRisk.rds")
contFireRisk <- readRDS("contFireRisk.rds")
```


```{r}
#visualize
fr <- ggplot() +
    geom_spatraster(data = contFireRisk , aes(fill = Band_1)) +
    scale_fill_viridis_c(option = "inferno",na.value = "transparent") +
    xlab(NULL)+
    ylab(NULL)+
    ggtitle(expression(paste("Fire Risk"))) + 
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5))+
   theme(panel.border = element_rect(colour = "black", fill=NA))

#The WHP has continous "fire risk values" that in this area go from 0 to 42223. Those are an index developed to indiccate Wildfire Hazard Potential (WHP). See metadata for more information. 
#This is a continuous dataset but much like BRAT is often presented as categorical for visualization purposes. 
```
##Fire risk vs. dam capacity
```{r}
contFireRisk$Band_1
contFireRisk_df <- as_data_frame(contFireRisk, xy=T)
summary(contFireRisk_df$Band_1)

summary(AllSierras_DamCapacity$oCC_EX)

fireDamExtract <- extract(contFireRisk, AllSierras_DamCapacity, xy = TRUE, touches = TRUE)
#AllSierras_DamCapacity$fireRisk <- extract(contFireRisk, AllSierras_DamCapacity, xy = TRUE, touches = TRUE)


```


##Fire risk intersection with high quality dam areas
###pull high quality areas
```{r}
highquality <- subset(AllSierras_DamCapacity, oCC_EX >= 5) #pull out good habitat
```


```{r}
palette_new <- colorRampPalette(colors = c( "#00FF50", "#4900FF"))(2)
#scales::show_col(palette_new)

hqDams <- ggplot(transform(highquality, DamCapacity=cut(oCC_EX, breaks = c(0,.1,2,5,15,40), include.lowest=T))) +
    geom_sf(aes(color = DamCapacity)) +
    scale_color_manual(values=palette_new)+
    xlab(NULL)+
    ylab(NULL)+
    ggtitle(expression(paste("High Quality Beaver Habitat"))) + 
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5)) +
    theme(panel.border = element_rect(colour = "black", fill=NA))
```

###Pull high fire risk pixels
```{r}
#Note: Cannot figure out how WHP classifies high and very high fire risk categories based on WHP values. Not included in metadata. For now, choosing top quartile. 
summary(contFireRisk$Band_1)
#Top quartile starts at 1095, so let's start at WHP = 2000 as high and very high risk areas (again, FOR NOW) this is conservative
#JK it might work better for plotting purposes if we use the median, which is about 350 so let's call it 400

highRisk <- contFireRisk
highRisk[highRisk[] < 2000] = NA 
plot(highRisk, zlim = c(0,70), main = "Filtered raster")

highfr <- ggplot() +
  geom_spatraster(data = highRisk, aes(fill = Band_1)) +
  scale_fill_viridis_c(option = "inferno",na.value = "transparent") +
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("High Risk Fire Areas"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5))+
  theme(panel.border = element_rect(colour = "black", fill=NA))
```

###Extract high risk and high quality overlap
```{r}
riskExtract <- extract(highRisk, highquality, xy = TRUE, touches = TRUE)
riskExtract <- riskExtract[,c(3,4,2)] #reorder for Rast function
riskExtract <- rast(riskExtract, type = 'xyz')
wkt <- crs(contFireRisk)
crs(riskExtract) <- wkt

hq <- ggplot() +
  geom_spatraster(data = riskExtract, aes(fill = Band_1)) +
  scale_fill_viridis_c(option = "inferno",na.value = "transparent") +
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("High Fire Risk and High Dam Capacity"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5))+
  theme(panel.border = element_rect(colour = "black", fill=NA))

summary(riskExtract)

result <- as.data.frame(riskExtract) %>%
  summarise(pixels = n()) %>% 
  mutate(`area m^2` = pixels * 270 * 270, #multiply by pixel area
         `area km^2` = round(`area m^2`/1e6,2)) 
#1365 km2 of fire resilience conferred 
```
###Extract ANY fire risk and high quality overlap
```{r}
fireExtract <- extract(contFireRisk, highquality, xy = TRUE, touches = TRUE)
fireExtract <- fireExtract[,c(3,4,2)] #reorder for Rast function
fireExtract <- rast(fireExtract, type = 'xyz')
wkt <- crs(contFireRisk)
crs(fireExtract) <- wkt

hq <- ggplot() +
  geom_spatraster(data = fireExtract, aes(fill = Band_1)) +
  scale_fill_viridis_c(option = "inferno",na.value = "transparent") +
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("High Fire Risk and High Dam Capacity"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5))+
  theme(panel.border = element_rect(colour = "black", fill=NA))

summary(fireExtract)

result <- as.data.frame(fireExtract) %>%
  summarise(pixels = n()) %>% 
  mutate(`area m^2` = pixels * 270 * 270, #multiply by pixel area
         `area km^2` = round(`area m^2`/1e6,2)) 
#1365 km2 of fire resilience conferred 
```
#Watershed-Grouped Figures
##Apply to watersheds
```{r}
#fireRisk_normalized = area of high fire risk pixels / total pixels 
WatershedBoundaries$npixels <- exact_extract(riskExtract, WatershedBoundaries, 'count')
WatershedBoundaries$area_m2 <- WatershedBoundaries$npixels*270*270  
WatershedBoundaries$area_km2 <- round(WatershedBoundaries$area_m2/1e6,2)
WatershedBoundaries$total_area <- as.numeric(st_area(WatershedBoundaries))
WatershedBoundaries$total_area_km2 <- round(WatershedBoundaries$total_area/1e6,2)
WatershedBoundaries$firerisk_normalized <- WatershedBoundaries$area_m2 / WatershedBoundaries$total_area



#firerisk_normalized_Streamshq = area of fire resilient pixels / pixels along streams 
#High fire risk pixels along streams
riskExtract_Streams <- extract(riskExtract, AllSierras_DamCapacity, xy = TRUE, touches = TRUE, na.rm=T)
riskExtract_Streams <- riskExtract_Streams[,c(3,4,2)] #reorder for Rast function
riskExtract_Streams <- riskExtract_Streams[complete.cases(riskExtract_Streams), ]
riskExtract_Streams <- rast(riskExtract_Streams, type = 'xyz')
wkt <- crs(contFireRisk)
crs(riskExtract_Streams) <- wkt
plot(riskExtract_Streams)
#make sure it's the right size
riskExtract_Streams <- extend(riskExtract_Streams, contFireRisk)
#extract to watersheds
WatershedBoundaries$npixels_Streams <- exact_extract(riskExtract_Streams, WatershedBoundaries, 'count')
WatershedBoundaries$area_m2_Streams <- WatershedBoundaries$npixels_Streams*270*270  
WatershedBoundaries$area_km2_Streams <- round(WatershedBoundaries$area_m2_Streams/1e6,2)


#High fire risk pixels along high quality streams
riskExtract_Streamshq <- extract(riskExtract, highquality, xy = TRUE, touches = TRUE)
riskExtract_Streamshq <- riskExtract_Streamshq[,c(3,4,2)] #reorder for Rast function
riskExtract_Streamshq <- riskExtract_Streamshq[complete.cases(riskExtract_Streamshq), ]
riskExtract_Streamshq <- rast(riskExtract_Streamshq, type = 'xyz')
wkt <- crs(contFireRisk)
crs(riskExtract_Streamshq) <- wkt
plot(riskExtract_Streamshq)
#make sure it's the right size
riskExtract_Streamshq <- extend(riskExtract_Streamshq, contFireRisk)
#extract to watersheds
WatershedBoundaries$npixels_Streamshq <- exact_extract(riskExtract_Streamshq, WatershedBoundaries, 'count')
WatershedBoundaries$area_m2_Streamshq <- WatershedBoundaries$npixels_Streams*270*270  
WatershedBoundaries$area_km2_Streamshq <- round(WatershedBoundaries$area_m2_Streams/1e6,2)
WatershedBoundaries$firerisk_normalized_Streamshq <- WatershedBoundaries$area_m2_Streamshq / WatershedBoundaries$total_area



#Normalized volume / stream km
AllSierras_DamCapacity$VolumePerKm <-  AllSierras_DamCapacity$volume/((AllSierras_DamCapacity$iGeo_Len)*0.001)
watersheds <- st_join(WatershedBoundaries,AllSierras_DamCapacity)

watersheds <- watersheds %>%
    group_by(geometry) %>% 
    summarise(normVol = mean(VolumePerKm))

WatershedBoundaries <- st_join(WatershedBoundaries, watersheds, by = "geometry")
```

```{r}
frw <- ggplot() +
  geom_sf(data = WatershedBoundaries, aes(fill = area_km2)) +
  scale_fill_viridis_c(option = 'inferno') + 
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("Fire Resilience (km2)"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5))+
  theme(panel.border = element_rect(colour = "black", fill=NA))
```

```{r}
frw_n <- ggplot() +
  geom_sf(data = WatershedBoundaries, aes(fill = firerisk_normalized)) +
  scale_fill_viridis_c(option = 'inferno') + 
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("Normalized Fire Resilience \n(% total area)"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5))+
  theme(panel.border = element_rect(colour = "black", fill=NA))
```


###Map vol, fire risk, current, and historic dam cap
```{r eval=FALSE, include=FALSE}
(h + c) / (currentVol + fr)
```

###Map grouped by watershed
```{r}
(histChange + avgBeavs) / (normVol + frw_n)
```



##Watershed-grouped table
```{r}
test <- watersheds %>%
    group_by(geometry) %>% 
    summarise(normVol = mean(VolumePerKm),
              totalVol = sum(volume),
              totalVolHist = sum(volumeHist),
              totalVolChange = sum(VolumeChange),
              totalBeavs = sum(mCC_EX_CT),
              avgBeavs = mean(oCC_EX),
              histBeavs = mean(oCC_HPE),
              histChange = mean(mCC_EXvHPE, na.rm=T))

test$npixels <- exact_extract(riskExtract, test, 'count')
test$area_m2 <- test$npixels*270*270  
test$area_km2 <- round(test$area_m2/1e6,2)
?rename
test_df <-as_data_frame(test, xy = T)

table1 <- test_df %>%
  dplyr::select(geometry, histBeavs, avgBeavs, histChange, totalVol, area_km2) %>%  
  dplyr:: rename(`Historical mean dam capacity (dams/km)` = histBeavs, 
                 `Current mean dam capacity (dams/km)` = avgBeavs, 
                 `Percent dam capacity remaining (%)` = histChange, 
                 `Total potential water storage (m3)` = totalVol, 
                 `Total area of potential fire resilience in high-risk fire areas (km2)` = area_km2)

st_as_sf(table1)
#st_write(table1, "table1.shp")
```



#Bivariate Colorpleth Map
######Put potential water storage into raster
```{r}
#convert to spatVector object
sv_AllSierras <- terra::vect(AllSierras_DamCapacity)

#Create empty raster called "er"
er <- rast(ext(contFireRisk), resolution=res(contFireRisk)) 
crs(er) <- crs(contFireRisk)

#Use rasterize function in terra to put volume column into a raster
nr <- terra::rasterize(sv_AllSierras, er, field= "volume", fun = "sum", touches = TRUE, update = TRUE)
plot(nr)

volumeR <- nr
saveRDS(volumeR, "volumeR.rds")

#Make sure fire risk (riskExtract) is on same raster scale as volume
fireResilience <- extend(riskExtract, contFireRisk)
fireResilienceSome <- extend(fireExtract, contFireRisk)


#Save as .tif files
writeRaster(fireResilienceSome, "fireResilienceSome.tif", overwrite=T)

writeRaster(fireResilience, "fireResilience.tif", overwrite=T)
writeRaster(volumeR, "waterStorage.tif", overwrite=T)
```




##Function producing color matrix (from Chapman et al. 2023)
```{r}
# The function that produces the colour matrix
colmat <- function(nbreaks = 3, breakstyle = "quantile",
                   upperleft = "#64ACBE", upperright = "#574249", 
                   bottomleft = "#E8E8E8", bottomright = "#C85A5A",
                   xlab = "x label", ylab = "y label", plotLeg = TRUE,
                   saveLeg = FALSE) {
   # TODO - replace any tidyr, dplyr etc. functions with data.table #
  library(tidyverse)
  require(ggplot2)
  require(classInt)
  library(data.table)
  if (breakstyle == "sd") {
    warning("SD breaks style cannot be used.\nWill not always return the correct number of breaks.\nSee classInt::classIntervals() for details.\nResetting to quantile",
            call. = FALSE, immediate. = FALSE)
    breakstyle <- "quantile"}
  # The colours can be changed by changing the HEX codes for:
  # upperleft, upperright, bottomleft, bottomright
  # From http://www.joshuastevens.net/cartography/make-a-bivariate-choropleth-map/
  # upperleft = "#64ACBE", upperright = "#574249", bottomleft = "#E8E8E8", bottomright = "#C85A5A",
  # upperleft = "#BE64AC", upperright = "#3B4994", bottomleft = "#E8E8E8", bottomright = "#5AC8C8",
  # upperleft = "#73AE80", upperright = "#2A5A5B", bottomleft = "#E8E8E8", bottomright = "#6C83B5", 
  # upperleft = "#9972AF", upperright = "#804D36", bottomleft = "#E8E8E8", bottomright = "#C8B35A",
  # upperleft = "#DA8DC8", upperright = "#697AA2", bottomleft = "#E8E8E8", bottomright = "#73BCA0",
  # Similar to Teuling, Stockli, Seneviratnea (2011) [https://doi.org/10.1002/joc.2153]
  # upperleft = "#F7900A", upperright = "#993A65", bottomleft = "#44B360", bottomright = "#3A88B5",
  # Viridis style
  # upperleft = "#FEF287", upperright = "#21908D", bottomleft = "#E8F4F3", bottomright = "#9874A1",
  # Similar to Fjeldsa, Bowie, Rahbek 2012
  # upperleft = "#34C21B", upperright = "#FFFFFF", bottomleft = "#595757",  bottomright = "#A874B8",
  # Default from original source
  # upperleft = "#0096EB", upperright = "#820050", bottomleft= "#BEBEBE", bottomright = "#FFE60F",
  my.data <- seq(0, 1, .01)
  # Default uses terciles (Lucchesi and Wikle [2017] doi: 10.1002/sta4.150)
  my.class <- classInt::classIntervals(my.data,
                                       n = nbreaks,
                                       style = breakstyle,
                                       )
  my.pal.1 <- classInt::findColours(my.class, c(upperleft, bottomleft))
  my.pal.2 <- classInt::findColours(my.class, c(upperright, bottomright))
  col.matrix <- matrix(nrow = 101, ncol = 101, NA)
  for (i in 1:101) {
    my.col <- c(paste(my.pal.1[i]), paste(my.pal.2[i]))
    col.matrix[102 - i, ] <- classInt::findColours(my.class, my.col)
  }
  ## need to convert this to data.table at some stage.
  col.matrix.plot <- col.matrix %>%
    as.data.frame(.) %>% 
    mutate("Y" = row_number()) %>%
    mutate_at(.tbl = ., .vars = vars(starts_with("V")), .funs = list(as.character)) %>% 
    pivot_longer(data = ., cols = -Y, names_to = "X", values_to = "HEXCode") %>% 
    mutate("X" = as.integer(sub("V", "", .$X))) %>%
    distinct(as.factor(HEXCode), .keep_all = TRUE) %>%
    mutate(Y = rev(.$Y)) %>% 
    dplyr::select(-c(4)) %>%
    mutate("Y" = rep(seq(from = 1, to = nbreaks, by = 1), each = nbreaks),
           "X" = rep(seq(from = 1, to = nbreaks, by = 1), times = nbreaks)) %>%
    mutate("UID" = row_number())
  # Use plotLeg if you want a preview of the legend
  if (plotLeg) {
    p <- ggplot(col.matrix.plot, aes(X, Y, fill = HEXCode)) +
      geom_tile() +
      scale_fill_identity() +
      coord_equal(expand = FALSE) +
      theme_void() +
      theme(aspect.ratio = 1,
            axis.title = element_text(size = 10, colour = "black",hjust = 0.5, 
                                      vjust = 1),
            axis.title.y = element_text(size = 10, angle = 90, hjust = 0.5, vjust = 1)) +
      xlab(bquote(.(xlab) ~  symbol("\256"))) +
      ylab(bquote(.(ylab) ~  symbol("\256")))
    print(p)
    assign(
      x = "BivLegend",
      value = p,
      pos = .GlobalEnv
    )
  }
  # Use saveLeg if you want to save a copy of the legend
  if (saveLeg) {
    ggsave(filename = "bivLegend.pdf", plot = p, device = "pdf",
           path = "./", width = 4, height = 4, units = "in",
           dpi = 300)
  }
  seqs <- seq(0, 100, (100 / nbreaks))
  seqs[1] <- 1
  col.matrix <- col.matrix[c(seqs), c(seqs)]
  attr(col.matrix, "breakstyle") <- breakstyle
  attr(col.matrix, "nbreaks") <- nbreaks
  return(col.matrix)
}



# Function to assign colour-codes to raster data
# As before, by default assign tercile breaks
bivariate.map <- function(rasterx, rastery, colourmatrix = col.matrix,
                          export.colour.matrix = TRUE,
                          outname = paste0("colMatrix_rasValues", names(rasterx))) {
  # TO DO - replace raster with terra #
  #require(raster)
  require(classInt)
  # export.colour.matrix will export a data.frame of rastervalues and RGB codes 
  # to the global environment outname defines the name of the data.frame
  quanx <- values(rasterx)
  tempx <- data.frame(quanx, quantile = rep(NA, length(quanx)))
  brks <- with(tempx, classIntervals(quanx,
                                    n = attr(colourmatrix, "nbreaks"),
                                    style = attr(colourmatrix, "breakstyle"))$brks)
  ## Add (very) small amount of noise to all but the first break
  ## https://stackoverflow.com/a/19846365/1710632
  brks[-1] <- brks[-1] + seq_along(brks[-1]) * .Machine$double.eps
  r1 <- within(tempx, quantile <- cut(quanx,
                                     breaks = brks,
                                     labels = 2:length(brks),
                                     include.lowest = TRUE))
  quantr <- data.frame(r1[, 2])
  quany <- values(rastery)
  tempy <- data.frame(quany, quantile = rep(NA, length(quany)))
  brksy <- with(tempy, classIntervals(quany,
                                     n = attr(colourmatrix, "nbreaks"),
                                     style = attr(colourmatrix, "breakstyle"))$brks)
  brksy[-1] <- brksy[-1] + seq_along(brksy[-1]) * .Machine$double.eps
  r2 <- within(tempy, quantile <- cut(quany,
                                     breaks = brksy,
                                     labels = 2:length(brksy),
                                     include.lowest = TRUE
  ))
  quantr2 <- data.frame(r2[, 2])
  as.numeric.factor <- function(x) {
    as.numeric(levels(x))[x]
  }
  col.matrix2 <- colourmatrix
  cn <- unique(colourmatrix)
  for (i in 1:length(col.matrix2)) {
    ifelse(is.na(col.matrix2[i]),
           col.matrix2[i] <- 1, col.matrix2[i] <- which(
             col.matrix2[i] == cn
           )[1]
    )
  }
  # Export the colour.matrix to data.frame() in the global env
  # Can then save with write.table() and use in ArcMap/QGIS
  # Need to save the output raster as integer data-type
  if (export.colour.matrix) {
    # create a dataframe of colours corresponding to raster values
    exportCols <- as.data.frame(cbind(
      as.vector(col.matrix2), as.vector(colourmatrix),
      t(col2rgb(as.vector(colourmatrix)))
    ))
    # rename columns of data.frame()
    colnames(exportCols)[1:2] <- c("rasValue", "HEX")
    #return(exportCols)
    # Export to the global environment
    assign(
      x = outname,
      value = exportCols,
      pos = .GlobalEnv
    )
  }
  cols <- numeric(length(quantr[, 1]))
  for (i in 1:length(quantr[, 1])) {
    a <- as.numeric.factor(quantr[i, 1])
    b <- as.numeric.factor(quantr2[i, 1])
    cols[i] <- as.numeric(col.matrix2[b, a])
  }
  r <- rasterx
  r[] <- cols
  return(r)
}

```


#######test 
```{r eval=FALSE, include=FALSE}
bivariate.map <- function(rasterx, rastery, colourmatrix = col.matrix,
                          export.colour.matrix = TRUE,
                          outname = paste0("colMatrix_rasValues", names(rasterx))) {
  # TO DO - replace raster with terra #
  #require(raster)
  require(classInt)
  
export.colour.matrix = TRUE  
colourmatrix = col.matrixQ  
rasterx <- fireResilienceAll
rastery <- waterStorage
outname= "test"
  # export.colour.matrix will export a data.frame of rastervalues and RGB codes 
  # to the global environment outname defines the name of the data.frame
  quanx <- values(rasterx)
  tempx <- data.frame(quanx, quantile = rep(NA, length(quanx)))
  brks <- with(tempx, classIntervals(quanx,
                                    n = attr(colourmatrix, "nbreaks"),
                                    style = attr(colourmatrix, "breakstyle"))$brks)
  ## Add (very) small amount of noise to all but the first break
  ## https://stackoverflow.com/a/19846365/1710632
  brks[-1] <- brks[-1] + seq_along(brks[-1]) * .Machine$double.eps
  r1 <- within(tempx, quantile <- cut(quanx,
                                     breaks = brks,
                                     labels = 2:length(brks),
                                     include.lowest = TRUE))
  quantr <- data.frame(r1[, 2])
  quany <- values(rastery)
  tempy <- data.frame(quany, quantile = rep(NA, length(quany)))
  brksy <- with(tempy, classIntervals(quany,
                                     n = attr(colourmatrix, "nbreaks"),
                                     style = attr(colourmatrix, "breakstyle"))$brks)
  brksy[-1] <- brksy[-1] + seq_along(brksy[-1]) * .Machine$double.eps
  r2 <- within(tempy, quantile <- cut(quany,
                                     breaks = brksy,
                                     labels = 2:length(brksy),
                                     include.lowest = TRUE
  ))
  quantr2 <- data.frame(r2[, 2])
  as.numeric.factor <- function(x) {
    as.numeric(levels(x))[x]
  }
  col.matrix2 <- colourmatrix
  cn <- unique(colourmatrix)
  for (i in 1:length(col.matrix2)) {
    ifelse(is.na(col.matrix2[i]),
           col.matrix2[i] <- 1, col.matrix2[i] <- which(
             col.matrix2[i] == cn
           )[1]
    )
  }
  # Export the colour.matrix to data.frame() in the global env
  # Can then save with write.table() and use in ArcMap/QGIS
  # Need to save the output raster as integer data-type
  if (export.colour.matrix) {
    # create a dataframe of colours corresponding to raster values
    exportCols <- as.data.frame(cbind(
      as.vector(col.matrix2), as.vector(colourmatrix),
      t(col2rgb(as.vector(colourmatrix)))
    ))
    # rename columns of data.frame()
    colnames(exportCols)[1:2] <- c("rasValue", "HEX")
    # Export to the global environment
    assign(
      x = outname,
      value = exportCols,
      pos = .GlobalEnv
    )
  }
  cols <- numeric(length(quantr[, 1]))
  for (i in 1:length(quantr[, 1])) {
    a <- as.numeric.factor(quantr[i, 1])
    b <- as.numeric.factor(quantr2[i, 1])
    cols[i] <- as.numeric(col.matrix2[b, a])
  }
  r <- rasterx
  r[1:length(r)] <- cols
  return(r)
}

str(cols)
length(cols) 
dim(rasterx)
2536*1476 == length(cols)
```
#######test
```{r eval=FALSE, include=FALSE}
nbreaks = 4
colmat <- function(nbreaks = 3, breakstyle = "quantile",
                   upperleft = "#64ACBE", upperright = "#574249", 
                   bottomleft = "#E8E8E8", bottomright = "#C85A5A",
                   xlab = "x label", ylab = "y label", plotLeg = TRUE,
                   saveLeg = FALSE) {
   # TODO - replace any tidyr, dplyr etc. functions with data.table #
  library(tidyverse)
  require(ggplot2)
  require(classInt)
  library(data.table)
  if (breakstyle == "sd") {
    warning("SD breaks style cannot be used.\nWill not always return the correct number of breaks.\nSee classInt::classIntervals() for details.\nResetting to quantile",
            call. = FALSE, immediate. = FALSE)
    breakstyle <- "quantile"}
  # The colours can be changed by changing the HEX codes for:
  # upperleft, upperright, bottomleft, bottomright
  # From http://www.joshuastevens.net/cartography/make-a-bivariate-choropleth-map/
  # upperleft = "#64ACBE", upperright = "#574249", bottomleft = "#E8E8E8", bottomright = "#C85A5A",
  # upperleft = "#BE64AC", upperright = "#3B4994", bottomleft = "#E8E8E8", bottomright = "#5AC8C8",
  # upperleft = "#73AE80", upperright = "#2A5A5B", bottomleft = "#E8E8E8", bottomright = "#6C83B5", 
  # upperleft = "#9972AF", upperright = "#804D36", bottomleft = "#E8E8E8", bottomright = "#C8B35A",
  # upperleft = "#DA8DC8", upperright = "#697AA2", bottomleft = "#E8E8E8", bottomright = "#73BCA0",
  # Similar to Teuling, Stockli, Seneviratnea (2011) [https://doi.org/10.1002/joc.2153]
  # upperleft = "#F7900A", upperright = "#993A65", bottomleft = "#44B360", bottomright = "#3A88B5",
  # Viridis style
  # upperleft = "#FEF287", upperright = "#21908D", bottomleft = "#E8F4F3", bottomright = "#9874A1",
  # Similar to Fjeldsa, Bowie, Rahbek 2012
  # upperleft = "#34C21B", upperright = "#FFFFFF", bottomleft = "#595757",  bottomright = "#A874B8",
  # Default from original source
  # upperleft = "#0096EB", upperright = "#820050", bottomleft= "#BEBEBE", bottomright = "#FFE60F",
  my.data <- seq(0, 1, .01)
  # Default uses terciles (Lucchesi and Wikle [2017] doi: 10.1002/sta4.150)
  my.class <- classInt::classIntervals(my.data,
                                       n = nbreaks,
                                       style = breakstyle,
                                       )
  my.pal.1 <- classInt::findColours(my.class, c(upperleft, bottomleft))
  my.pal.2 <- classInt::findColours(my.class, c(upperright, bottomright))
  col.matrix <- matrix(nrow = 101, ncol = 101, NA)
  for (i in 1:101) {
    my.col <- c(paste(my.pal.1[i]), paste(my.pal.2[i]))
    col.matrix[102 - i, ] <- classInt::findColours(my.class, my.col)
  }
  ## need to convert this to data.table at some stage.
  col.matrix.plot <- col.matrix %>%
    as.data.frame(.) %>% 
    mutate("Y" = row_number()) %>%
    mutate_at(.tbl = ., .vars = vars(starts_with("V")), .funs = list(as.character)) %>% 
    pivot_longer(data = ., cols = -Y, names_to = "X", values_to = "HEXCode") %>% 
    mutate("X" = as.integer(sub("V", "", .$X))) %>%
    distinct(as.factor(HEXCode), .keep_all = T) %>%
    mutate(Y = rev(.$Y)) %>% 
    dplyr::select(-c(4)) %>%
    mutate("Y" = rep(seq(from = 1, to = nbreaks, by = 1), each = nbreaks),
           "X" = rep(seq(from = 1, to = nbreaks, by = 1), times = nbreaks)) %>%
    mutate("UID" = row_number())
  # Use plotLeg if you want a preview of the legend
  if (plotLeg) {
    p <- ggplot(col.matrix.plot, aes(X, Y, fill = HEXCode)) +
      geom_tile() +
      scale_fill_identity() +
      coord_equal(expand = FALSE) +
      theme_void() +
      theme(aspect.ratio = 1,
            axis.title = element_text(size = 10, colour = "black",hjust = 0.5, 
                                      vjust = 1),
            axis.title.y = element_text(size = 10, angle = 90, hjust = 0.5, vjust = 1)) +
      xlab(bquote(.(xlab) ~  symbol("\256"))) +
      ylab(bquote(.(ylab) ~  symbol("\256")))
    print(p)
    assign(
      x = "BivLegend",
      value = p,
      pos = .GlobalEnv
    )
  }
  # Use saveLeg if you want to save a copy of the legend
  if (saveLeg) {
    ggsave(filename = "bivLegend.pdf", plot = p, device = "pdf",
           path = "./", width = 4, height = 4, units = "in",
           dpi = 300)
  }
  seqs <- seq(0, 100, (100 / nbreaks))
  seqs[1] <- 1
  col.matrix <- col.matrix[c(seqs), c(seqs)]
  attr(col.matrix, "breakstyle") <- breakstyle
  attr(col.matrix, "nbreaks") <- nbreaks
  return(col.matrix)
}

bivmapQ

```


#16 colors
##Read in your data
```{r}
#read in your data 
plot(waterStorage)
fireResilience <- rast("fireResilience.tif")
#fireResilience[is.na(fireResilience[])] <- 0
waterStorage <- rast("waterStorage.tif")
r <- c(fireResilience, waterStorage)
names(r) <- c("fireResilience","waterStorage")

```

```{r}
volumeR[(volumeR[] == 0)] <- NA

vras <- ggplot() +
  geom_spatraster(data = volumeR, aes(fill = volume)) +
  scale_fill_viridis_c(option = "plasma",na.value = "transparent") +
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("Water Storage"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5))+
  theme(panel.border = element_rect(colour = "black", fill=NA))

fireResilience[(fireResilience[] == 0)] <- NA
fras <- ggplot() +
  geom_spatraster(data = fireResilience, aes(fill = Band_1)) +
  scale_fill_viridis_c(option = "inferno",na.value = "transparent") +
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("High Fire Resilience"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5))+
  theme(panel.border = element_rect(colour = "black", fill=NA))

vras + fras

```
#######test
```{r eval=FALSE, cache=TRUE, include=FALSE}
# Define the number of breaks
nBreaks <- 4

# Create the colour matrix
col.matrixQ <- colmat(nbreaks = nBreaks, breakstyle = "quantile",
                       xlab = "Fire", ylab = "Water", 
                       bottomright = "#C85A5A", upperright = "#574249",
                       bottomleft = "#E8E8E8", upperleft = "#64ACBE",
                       saveLeg = FALSE, plotLeg = TRUE)


# create the bivariate raster
if (!file.exists("bivmapQ_pull.tif")) {
  bivmapQ_pull <- bivariate.map(rasterx = r[["fireResilience"]], rastery = r[["waterStorage"]],
                          export.colour.matrix = TRUE,
                          colourmatrix = col.matrixQ)
  writeRaster(bivmapQ_pull, "bivmapQ_pull.tif")
}
bivmapQ_pull <- rast("bivmapQ_pull.tif")

# Convert to dataframe for plotting with ggplot
library(data.table)
bivmapQ_pullDFQ <- setDT(as.data.frame(bivmapQ_pull, xy = TRUE))
colnames(bivMapDFQ)[3] <- "BivValue"
bivmapQ_pullDFQ <- melt(bivmapQ_pullDFQ, id.vars = c("x", "y"),
                   measure.vars = "BivValue",
                   value.name = "bivVal",
                   variable.name = "Variable")

# Make the map using ggplot
map_q2 <- ggplot() +
    geom_raster(data = bivmapQ_pullDFQ, aes(x = x, y = y, fill = bivVal)) +
      scale_fill_gradientn(colours = col.matrixQ, na.value = "transparent") + 
    theme_classic() + theme(panel.grid.major = element_blank(),
                            panel.grid.minor = element_blank()) +
    theme(text = element_text(size = 10, colour = "black")) +
    borders(colour = "black", size = 0.1) +
    coord_quickmap() +
    theme(legend.position = "none",
          plot.background = element_blank(),
          strip.text = element_blank(), 
          #axis.text.y = element_blank(),
          #axis.text = element_blank(),
          axis.title = element_blank())

map_q2 <- map_q2 + inset_element(BivLegend, 0, 0, 0.2, 0.3)
```
##Try map again using full fire risk raster
##Put potential water storage into raster
```{r}
#convert to spatVector object
sv_AllSierras <- terra::vect(AllSierras_DamCapacity)

#Create empty raster called "er"
er <- rast(ext(contFireRisk), resolution=res(contFireRisk)) 
crs(er) <- crs(contFireRisk)

#Use rasterize function in terra to put volume column into a raster
nr <- terra::rasterize(sv_AllSierras, er, field= "volume", fun = "sum", touches = TRUE, update = TRUE)
plot(nr)

volumeR <- nr
saveRDS(volumeR, "volumeR.rds")

#Make sure fire risk (riskExtract) is on same raster scale as volume
fireResilience <- extend(riskExtract, contFireRisk)

#Save as .tif files
writeRaster(fireResilience, "fireResilience.tif", overwrite=TRUE)
writeRaster(volumeR, "waterStorage.tif", overwrite=T)
writeRaster(contFireRisk, "fireResilienceAll.tif", overwrite=T)
```

##Read in your data
```{r eval=FALSE, include=FALSE}
#read in your data 


fireResilienceAll <- rast("fireResilienceAll.tif")
#fireResilience[is.na(fireResilience[])] <- 0
waterStorage <- rast("waterStorage.tif")
r <- c(fireResilienceAll, waterStorage)
names(r) <- c("fireResilienceAll","waterStorage")


plot(fireResilienceAll)
plot(waterStorage)
```
##HELL YES IT WORKED
```{r eval=FALSE, cache=TRUE, include=FALSE}
# Define the number of breaks
nBreaks <- 4

# Create the colour matrix
col.matrixQ <- colmat(nbreaks = nBreaks, breakstyle = "quantile",
                       xlab = "Fire", ylab = "Water", 
                      bottomright = "#C85A5A", upperright = "#574249",
                       bottomleft = "#E8E8E8", upperleft = "#64ACBE",
                       saveLeg = FALSE, plotLeg = TRUE)


# create the bivariate raster
#if (!file.exists("bivmapQ.tif")) {
  bivmapQ <- bivariate.map(rasterx = r[["fireResilienceAll"]], rastery = r[["waterStorage"]],
                          export.colour.matrix = TRUE,
                          colourmatrix = col.matrixQ, 
                          )
  writeRaster(bivmapQ, "bivmapQ.tif", overwrite = T)
#}
bivmapQ <- rast("bivmapQ.tif")
saveRDS(bivmapQ, 'bivmapQ.rds')

# Convert to dataframe for plotting with ggplot
library(data.table)
bivMapDFQ <- setDT(as.data.frame(bivmapQ, xy = TRUE))
colnames(bivMapDFQ)[3] <- "BivValue"
bivMapDFQ <- melt(bivMapDFQ, id.vars = c("x", "y"),
                   measure.vars = "BivValue",
                   value.name = "bivVal",
                   variable.name = "Variable")

# Make the map using ggplot
map_q <- ggplot() +
    geom_raster(data = bivMapDFQ, aes(x = x, y = y, fill = bivVal)) +
      scale_fill_gradientn(colours = col.matrixQ, na.value = "transparent") + 
    #geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
    theme_classic() + theme(panel.grid.major = element_blank(),
                            panel.grid.minor = element_blank()) +
    theme(text = element_text(size = 10, colour = "black")) +
    borders(colour = "black", size = 0.1) +
    coord_quickmap() +
    theme(legend.position = "none",
          plot.background = element_blank(),
          strip.text = element_blank(), 
          #axis.text.y = element_blank(),
          #axis.text = element_blank(),
          axis.title = element_blank())

map_q <- map_q + inset_element(BivLegend, 0, 0, 0.2, 0.3)

```


#4 colors
##Make a 2x2 color matrix for vis purposes
```{r}
# Define the number of breaks
nBreaks2 <- 2

# Create the colour matrix
col.matrixQ2 <- colmat(nbreaks = nBreaks2, breakstyle = "quantile",
                       xlab = "Fire", ylab = "Water", 
                      bottomright = "#C85A5A", upperright = "#574249",
                       bottomleft = "#E8E8E8", upperleft = "#64ACBE",
                       saveLeg = FALSE, plotLeg = TRUE)

palette_biv2 <- colorRampPalette(colors = c("#574249", "#C85A5A", "#E8E8E8", "#64ACBE"))(4)


```

##New matrix
```{r eval=FALSE, include=FALSE}
colMatrix_rasValuesfireResilienceAll %>%
  distinct(rasValue, HEX)

show_col(colMatrix_rasValuesfireResilienceAll$HEX)
#HOOK UP THE COLOR WITH THE  HEX CODE and the  raster number 

#select for a 2x2 color panel for visualizing
bivmap_simple = bivmapQ %>% 
  mutate(color = ifelse(fireResilienceAll %in% c(1,2,9,10),"neither",
                       ifelse(fireResilienceAll %in% c(3,4,11,12),"water",
                              ifelse(fireResilienceAll %in% c(13,14,17,18),"fire","both"))))
#check and see what it looks like
plot(bivmap_simple$color)
unique(bivmap_simple$color)
#1	both			
#2	fire			
#3	neither			
#4	water
```


#Try again with fire extracted to stream network

##extract data
```{r}
#Extract fire layer to just streams
fireStreams <- extract(contFireRisk, AllSierras_DamCapacity, xy = TRUE, touches = TRUE)
fireStreams <- fireStreams[,c(3,4,2)] #reorder for Rast function
fireStreams <- rast(fireStreams, type = 'xyz')
wkt <- crs(contFireRisk)
crs(fireStreams) <- wkt
plot(fireStreams)
plot(waterStorage)

#make sure it's the right size
fireStreams <- extend(fireStreams, contFireRisk)

#save as raster
writeRaster(fireStreams, "fireStreams.tif", overwrite=T)

#read in your data 
fireStreams <- rast("fireStreams.tif")
waterStorage <- rast("waterStorage.tif")
#waterStorage[(waterStorage[] == 0)] <- NA
#fireStreams[(fireStreams[] == 0)] <- NA
r2 <- c(fireStreams, waterStorage)
names(r2) <- c("fireStreams","waterStorage")
```

##try with 4 colors
```{r cache=TRUE}
# Define the number of breaks
nBreaks <- 2

# Create the colour matrix
col.matrixQ2 <- colmat(nbreaks = nBreaks, breakstyle = "quantile",
                       xlab = "Fire", ylab = "Water", 
                      bottomright = "#C85A5A", upperright = "#574249",
                       bottomleft = "#E8E8E8", upperleft = "#64ACBE",
                       saveLeg = TRUE, plotLeg = TRUE)


# create the bivariate raster
#if (!file.exists("bivmapQ.tif")) {
  bivmapQ2 <- bivariate.map(rasterx = r2[["fireStreams"]], rastery = r2[["waterStorage"]],
                          export.colour.matrix = TRUE,
                          colourmatrix = col.matrixQ2, 
                          )
  writeRaster(bivmapQ2, "bivmapQ2.tif", overwrite = T)
#}
bivmapQ2 <- rast("bivmapQ2.tif")
saveRDS(bivmapQ2, 'bivmapQ2.rds')

# Convert to dataframe for plotting with ggplot
library(data.table)
bivMapDFQ2 <- setDT(as.data.frame(bivmapQ2, xy = TRUE))
colnames(bivMapDFQ2)[3] <- "BivValue"
bivMapDFQ2 <- melt(bivMapDFQ2, id.vars = c("x", "y"),
                   measure.vars = "BivValue",
                   value.name = "bivVal",
                   variable.name = "Variable")

plot(bivmapQ2)
# Make the map using ggplot
map_q2 <- ggplot() +
    geom_raster(data = bivMapDFQ2, aes(x = x, y = y, fill = bivVal)) +
      scale_fill_gradientn(colours = col.matrixQ2, na.value = "transparent") + 
    #geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
    theme_classic() + theme(panel.grid.major = element_blank(),
                            panel.grid.minor = element_blank()) +
    theme(text = element_text(size = 10, colour = "black")) +
    borders(colour = "black", size = 0.1) +
    coord_quickmap() +
    theme(legend.position = "none",
          plot.background = element_blank(),
          strip.text = element_blank(), 
          #axis.text.y = element_blank(),
          #axis.text = element_blank(),
          axis.title = element_blank())

map_q2 <- map_q2 + inset_element(BivLegend, 0, 0, 0.2, 0.3)

```
##post processing
```{r}
colMatrix_rasValuesfireStreams %>%
  distinct(rasValue, HEX)

show_col(colMatrix_rasValuesfireStreams$HEX)
#HOOK UP THE COLOR WITH THE  HEX CODE and the  raster number 

#check and see what it looks like
plot(bivmapQ2)
unique(bivmapQ2)
#1	neither			
#2	water			
#5	fire			
#6	both

#hook up to watershed boundaries to aggregate by watershed
WatershedBoundaries$bivmap <- exact_extract(bivmapQ2$fireStreams, WatershedBoundaries, 'frac')
WatershedBoundaries$bivmap_mode <- exact_extract(bivmapQ2$fireStreams, WatershedBoundaries, 'mode')
WatershedBoundaries$cat <- ifelse(WatershedBoundaries$bivmap_mode == 1,"neither",
                       ifelse(WatershedBoundaries$bivmap_mode == 2,"water",
                              ifelse(WatershedBoundaries$bivmap_mode == 5,"fire","both")))


map_w <- ggplot() +
  geom_sf(data = WatershedBoundaries, aes(fill = cat), na.rm=T) +
  scale_fill_manual(values=palette_biv2) + 
  xlab(NULL)+
  ylab(NULL)+
  #ggtitle(expression(paste("Majority of Area in Watershed"))) + 
  theme_minimal() +
  theme(panel.grid.major = element_line(colour = "transparent")) +
  theme(axis.text.x = element_blank(), axis.text.y = element_blank()) +
  theme(legend.position = "none")
  #theme(plot.title = element_text(hjust = 0.5, size = 12),
          #plot.subtitle = element_text(hjust = 0.5))+
  #theme(panel.border = element_rect(colour = "black", fill=NA))
#So there are no watersheds where the majority of pixels are water (4) or both (1) 


```
##Watershed-Grouping
###Apply to watersheds
```{r}
#Did this already with: 
#WatershedBoundaries$bivmap <- exact_extract(bivmapQ2$fireStreams, WatershedBoundaries, 'frac')

```

```{r}
WatershedBoundariesdf <- st_drop_geometry(WatershedBoundaries)
WatershedBoundariesdf$frac_1 <- WatershedBoundariesdf$bivmap[[1]]
WatershedBoundariesdf$frac_2 <- WatershedBoundariesdf$bivmap[[2]]
WatershedBoundariesdf$frac_5 <- WatershedBoundariesdf$bivmap[[3]]
WatershedBoundariesdf$frac_6 <- WatershedBoundariesdf$bivmap[[4]]
WatershedBoundariesdf <- WatershedBoundariesdf %>%
  mutate(HUCID_num = as.numeric(sub("^HUC ", "", as.character(HUCID)))) %>% 
  mutate(HUCID_num = as.character(HUCID_num))


data_long <- tidyr::pivot_longer(WatershedBoundariesdf, cols = c(frac_1, frac_2, frac_5, frac_6), names_to = "variable", values_to = "percentage")

# Plot
map_b <- ggplot(data_long, aes(x = HUCID_num, y = percentage, fill = variable)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c("frac_1" = "#E8E8E8", "frac_2" = "#64ACBE", "frac_5" ="#C85A5A", "frac_6" ="#574249")) +
  labs(title = "Percentage of watershed in each category",
       x = "HUC ID",
       y = "Percentage") +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  theme(panel.grid = element_blank())+
  theme(legend.position = "none")


```


#9 colors Try again with fire extracted to stream network
##palette
```{r}
# Define the number of breaks
nBreaks3 <- 3

# Create the colour matrix
col.matrixQ3 <- colmat(nbreaks = nBreaks3, breakstyle = "quantile",
                       xlab = "Fire", ylab = "Water", 
                      bottomright = "#C85A5A", upperright = "#574249",
                       bottomleft = "#E8E8E8", upperleft = "#64ACBE",
                       saveLeg = FALSE, plotLeg = TRUE)

palette_biv3 <- colorRampPalette(colors = c("#E8E8E8", "#A5CAD3", "#64ACBE", "#D8A1A1", "#9A8C92","#5D7783","#C85A5A","#8F4E51","#574249"))(9)



```

##extract data
```{r}

#read in your data 
fireStreams <- rast("fireStreams.tif")
waterStorage <- rast("waterStorage.tif")
waterStorage[(waterStorage[] == 0)] <- NA
fireStreams[(fireStreams[] == 0)] <- NA
r3 <- c(fireStreams, waterStorage)
names(r3) <- c("fireStreams","waterStorage")
```

##try with 9 colors
```{r cache=TRUE}
# Define the number of breaks
nBreaks <- 3

# Create the colour matrix
col.matrixQ3 <- colmat(nbreaks = nBreaks, breakstyle = "quantile",
                       xlab = "Fire", ylab = "Water", 
                      bottomright = "#C85A5A", upperright = "#574249",
                       bottomleft = "#E8E8E8", upperleft = "#64ACBE",
                       saveLeg = F, plotLeg = TRUE)


# create the bivariate raster
#if (!file.exists("bivmapQ.tif")) {
  bivmapQ3 <- bivariate.map(rasterx = r3[["fireStreams"]], rastery = r3[["waterStorage"]],
                          export.colour.matrix = TRUE,
                          colourmatrix = col.matrixQ3, 
                          )
  writeRaster(bivmapQ3, "bivmapQ3.tif", overwrite = T)
#}
bivmapQ3 <- rast("bivmapQ3.tif")
saveRDS(bivmapQ3, 'bivmapQ3.rds')

# Convert to dataframe for plotting with ggplot
library(data.table)
bivMapDFQ3 <- setDT(as.data.frame(bivmapQ3, xy = TRUE))
colnames(bivMapDFQ3)[3] <- "BivValue"
bivMapDFQ3 <- melt(bivMapDFQ3, id.vars = c("x", "y"),
                   measure.vars = "BivValue",
                   value.name = "bivVal",
                   variable.name = "Variable")

plot(bivmapQ3)
# Make the map using ggplot
map_q3 <- ggplot() +
    geom_raster(data = bivMapDFQ3, aes(x = x, y = y, fill = bivVal)) +
      scale_fill_gradientn(colours = col.matrixQ3, na.value = "transparent") + 
    #geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
    theme_classic() + theme(panel.grid.major = element_blank(),
                            panel.grid.minor = element_blank()) +
    theme(text = element_text(size = 10, colour = "black")) +
    borders(colour = "black", size = 0.1) +
    coord_quickmap() +
    theme(legend.position = "none",
          plot.background = element_blank(),
          strip.text = element_blank(), 
          #axis.text.y = element_blank(),
          #axis.text = element_blank(),
          axis.title = element_blank())

map_q3 <- map_q3 + inset_element(BivLegend, 0, 0, 0.2, 0.3)

```


##post processing
```{r}
colMatrix_rasValuesfireStreams %>%
  distinct(rasValue, HEX)

show_col(colMatrix_rasValuesfireStreams$HEX)
#HOOK UP THE COLOR WITH THE  HEX CODE and the  raster number 

#check and see what it looks like
plot(bivmapQ3)

#hook up to watershed boundaries to aggregate by watershed
WatershedBoundaries$bivmap3 <- exact_extract(bivmapQ3$fireStreams, WatershedBoundaries, 'frac')
WatershedBoundaries$bivmap_mode3 <- exact_extract(bivmapQ3$fireStreams, WatershedBoundaries, 'mode')

#NOT AGGREGATING--- JUST DOING 9 categories 
#WatershedBoundaries$cat <- ifelse(WatershedBoundaries$bivmap_mode == 1,"neither",
                      # ifelse(WatershedBoundaries$bivmap_mode == 2,"water",
                          #    ifelse(WatershedBoundaries$bivmap_mode == 5,"fire","both")))


map_w3 <- ggplot() +
  geom_sf(data = WatershedBoundaries, aes(fill = cat), na.rm=T) +
  scale_fill_manual(values=palette_biv3) + 
  xlab(NULL)+
  ylab(NULL)+
  #ggtitle(expression(paste("Majority of Area in Watershed"))) + 
  theme_minimal() +
  theme(panel.grid.major = element_line(colour = "transparent")) +
  theme(axis.text.x = element_blank(), axis.text.y = element_blank()) +
  theme(legend.position = "none")
  #theme(plot.title = element_text(hjust = 0.5, size = 12),
          #plot.subtitle = element_text(hjust = 0.5))+
  #theme(panel.border = element_rect(colour = "black", fill=NA))
#So there are no watersheds where the majority of pixels are water (4) or both (1) 


```
##Watershed-Grouping
###Apply to watersheds
```{r}
#Did this already with: 
#WatershedBoundaries$bivmap <- exact_extract(bivmapQ2$fireStreams, WatershedBoundaries, 'frac')

```

```{r}
WatershedBoundariesdf3 <- st_drop_geometry(WatershedBoundaries)
WatershedBoundariesdf3$frac_1 <- WatershedBoundariesdf3$bivmap3[[1]]
WatershedBoundariesdf3$frac_2 <- WatershedBoundariesdf3$bivmap3[[2]]
WatershedBoundariesdf3$frac_3 <- WatershedBoundariesdf3$bivmap3[[3]]
WatershedBoundariesdf3$frac_7 <- WatershedBoundariesdf3$bivmap3[[4]]
WatershedBoundariesdf3$frac_8 <- WatershedBoundariesdf3$bivmap3[[5]]
WatershedBoundariesdf3$frac_9 <- WatershedBoundariesdf3$bivmap3[[6]]
WatershedBoundariesdf3$frac_10 <- WatershedBoundariesdf3$bivmap3[[7]]
WatershedBoundariesdf3$frac_11 <- WatershedBoundariesdf3$bivmap3[[8]]
WatershedBoundariesdf3$frac_12 <- WatershedBoundariesdf3$bivmap3[[9]]

WatershedBoundariesdf3 <- WatershedBoundariesdf3 %>%
  mutate(HUCID_num = as.numeric(sub("^HUC ", "", as.character(HUCID)))) %>% 
  mutate(HUCID_num = as.character(HUCID_num))


data_long3 <- tidyr::pivot_longer(WatershedBoundariesdf3, cols = c(frac_1, frac_2, frac_3, frac_7, frac_8, frac_9, frac_10, frac_11, frac_12), names_to = "variable", values_to = "percentage")

# Plot
map_b3 <- ggplot(data_long3, aes(x = HUCID_num, y = percentage, fill = variable)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c("frac_1" = "#E8E8E8", "frac_2" = "#A5CAD3", "frac_3" ="#64ACBE", "frac_7" ="#D8A1A1", "frac_8" = "#9A8C92", "frac_9" = "#5D7783", 'frac_10' = "#C85A5A", 'frac_11' = "#8F4E51", 'frac_12' = "#574249")) +
  labs(title = "Percentage of watershed in each category",
       x = "HUC ID",
       y = "Percentage") +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))+
  theme(panel.grid = element_blank())+
  theme(legend.position = "none")

1	#E8E8E8			
2	#A5CAD3			
3	#64ACBE			
7	#D8A1A1			
8	#9A8C92			
9	#5D7783			
10	#C85A5A			
11	#8F4E51			
12	#574249
```



#Try again with fire extracted to beavers and stream network

##extract data
```{r}
#Extract fire layer to just hq streams
highRisk_Streamshq <- extract(highRisk, highquality, xy = TRUE, touches = TRUE)
highRisk_Streamshq <- highRisk_Streamshq[,c(3,4,2)] #reorder for Rast function
highRisk_Streamshq <- rast(highRisk_Streamshq, type = 'xyz')
wkt <- crs(contFireRisk)
crs(highRisk_Streamshq) <- wkt
highRiskHighQualtest <- highRisk_Streamshq

#make sure it's the right size
waterStorage <- rast("waterStorage.tif")
highRiskHighQualtest <- extend(highRiskHighQualtest, waterStorage)

plot(highRiskHighQual)
plot(waterStorage)

#save as raster
writeRaster(highRiskHighQualtest, "highRiskHighQual2.tif", overwrite=TRUE)

#read in your data 
highRiskHighQual <- rast("highRiskHighQual2.tif")
waterStorage <- rast("waterStorage.tif")
waterStorage[is.na(waterStorage)] <- 0
highRiskHighQual[is.na(highRiskHighQual)] <- 0
waterStorage <- mask(waterStorage, WatershedBoundaries)
highRiskHighQual <- mask(highRiskHighQual, WatershedBoundaries)
#highRiskHighQual[(highRiskHighQual[]==0)] <- NA
waterStorage[(waterStorage[]==0)] <- NA

r4 <- c(highRiskHighQual, waterStorage)
names(r4) <- c("highRiskHighQual","waterStorage")
```

##YAY try with 4 colors
```{r cache=TRUE}
# Define the number of breaks
nBreaks <- 2

# Create the colour matrix
col.matrixQ4 <- colmat(nbreaks = nBreaks, breakstyle = "quantile",
                       xlab = "Fire", ylab = "Water", 
                      bottomright = "#C85A5A", upperright = "#574249",
                       bottomleft = "#E8E8E8", upperleft = "#64ACBE",
                       saveLeg = TRUE, plotLeg = TRUE)


# create the bivariate raster
#if (!file.exists("bivmapQ.tif")) {
  bivmapQ4 <- bivariate.map(rasterx = r4[["highRiskHighQual"]], rastery = r4[["waterStorage"]],
                          export.colour.matrix = TRUE,
                          colourmatrix = col.matrixQ4, 
                          )
  writeRaster(bivmapQ4, "bivmapQ4.tif", overwrite = T)
#}
bivmapQ4 <- rast("bivmapQ4.tif")
saveRDS(bivmapQ4, 'bivmapQ4.rds')

# Convert to dataframe for plotting with ggplot
library(data.table)
bivMapDFQ4 <- setDT(as.data.frame(bivmapQ4, xy = TRUE))
colnames(bivMapDFQ4)[3] <- "BivValue"
bivMapDFQ4 <- melt(bivMapDFQ4, id.vars = c("x", "y"),
                   measure.vars = "BivValue",
                   value.name = "bivVal",
                   variable.name = "Variable")

plot(bivmapQ4)
# Make the map using ggplot



map_q5 <- ggplot() +
    geom_tile(data = bivMapDFQ4, aes(x = x, y = y, fill = bivVal)) +
      scale_fill_gradientn(colours = col.matrixQ4, na.value = "transparent") + 
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA, color = '#939393') +
    theme_classic() + theme(panel.grid.major = element_blank(),
                            panel.grid.minor = element_blank()) +
    theme(text = element_text(size = 10, colour = "black")) +
    borders(colour = "black", size = 0.1) +
    coord_sf() +
    theme(legend.position = "none",
          plot.background = element_blank(),
          strip.text = element_blank(), 
          #axis.text.y = element_blank(),
          #axis.text = element_blank(),
          axis.title = element_blank())

map_q5 <- map_q5 + inset_element(BivLegend, 0, 0, 0.3, 0.2)
```
##post processing 4 colors
```{r}
colMatrix_rasValueshighRiskHighQual %>%
  distinct(rasValue, HEX)
#1	#E8E8E8			
#2	#64ACBE	blue	
#5	#C85A5A		red
#6	#574249  purple

show_col(colMatrix_rasValueshighRiskHighQual$HEX)
#HOOK UP THE COLOR WITH THE  HEX CODE and the  raster number 

#check and see what it looks like
plot(bivmapQ4)
unique(bivmapQ4)


#hook up to watershed boundaries to aggregate by watershed
WatershedBoundaries$bivmap <- exact_extract(bivmapQ4$highRiskHighQual, WatershedBoundaries, 'frac')
WatershedBoundaries$bivmap_mode <- exact_extract(bivmapQ4$highRiskHighQual, WatershedBoundaries, 'mode')
WatershedBoundaries$cat <- ifelse(WatershedBoundaries$bivmap_mode == 1,"neither",ifelse(WatershedBoundaries$bivmap_mode == 2,"water", ifelse(WatershedBoundaries$bivmap_mode == 5,"fire","both")))

palette_biv2 <- colorRampPalette(colors = c("#574249", "#64ACBE", "#E8E8E8", "#C85A5A"))(4)

map_w <- ggplot() +
  geom_sf(data = WatershedBoundaries, aes(fill = cat), na.rm=T) +
  scale_fill_manual(values=palette_biv2) + 
  xlab(NULL)+
  ylab(NULL)+
  #ggtitle(expression(paste("Majority of Area in Watershed"))) + 
  theme_minimal() +
  theme(panel.grid.major = element_line(colour = "transparent")) +
  theme(axis.text.x = element_blank(), axis.text.y = element_blank()) +
  theme(legend.position = "none")
  #theme(plot.title = element_text(hjust = 0.5, size = 12),
          #plot.subtitle = element_text(hjust = 0.5))+
  #theme(panel.border = element_rect(colour = "black", fill=NA))
#So there are no watersheds where the majority of pixels are water (4) or both (1) 
WatershedBoundariesdf4 <- st_drop_geometry(WatershedBoundaries)
WatershedBoundariesdf4$frac_1 <- WatershedBoundariesdf4$bivmap[[1]]
WatershedBoundariesdf4$frac_2 <- WatershedBoundariesdf4$bivmap[[2]]
WatershedBoundariesdf4$frac_5 <- WatershedBoundariesdf4$bivmap[[3]]
WatershedBoundariesdf4$frac_6 <- WatershedBoundariesdf4$bivmap[[4]]

WatershedBoundariesdf4 <- WatershedBoundariesdf4 %>%
  mutate(HUCID_num = as.numeric(sub("^HUC ", "", as.character(HUCID)))) %>% 
  mutate(HUCID_num = as.character(HUCID_num))

data_long4 <- tidyr::pivot_longer(WatershedBoundariesdf4, cols = c(frac_1, frac_2, frac_5, frac_6), names_to = "variable", values_to = "percentage")

data_long4_summary <- data_long4 %>%
  filter(variable == "frac_6") 
summary(data_long4_summary$percentage)
hist(data_long4_summary$percentage)
data_long4_summary <- data_long4_summary[order(data_long4_summary$percentage, decreasing = TRUE),]
```


```{r}

bold_labels <-c("18040011","18020125","18040012", "18020126", "18020128","18020129", "18040013")

colorado <- function(src, boulder) {
  if (!is.factor(src)) src <- factor(src)                   # make sure it's a factor
  src_levels <- levels(src)                                 # retrieve the levels in their order
  brave <- boulder %in% src_levels                          # make sure everything we want to make bold is actually in the factor levels
  if (all(brave)) {                                         # if so
    b_pos <- purrr::map_int(boulder, ~which(.==src_levels)) # then find out where they are
    b_vec <- rep("plain", length(src_levels))               # make'm all plain first
    b_vec[b_pos] <- "bold"                                  # make our targets bold
    b_vec                                                   # return the new vector
  } else {
    stop("All elements of 'boulder' must be in src")
  }
}

# Plot
map_b4 <- ggplot(data_long4, aes(x = HUCID_num, y = percentage, fill = variable)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c(
    "frac_1" = "#E8E8E8", 
    'frac_2' = "#64ACBE", 
    "frac_5" = "#C85A5A", 
    "frac_6" = "#574249" 
    )) +
  labs(title = "Percentage of streams in each category",
       x = "HUC ID",
       y = "Percentage") +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+
  theme(axis.text.x=element_text(face=colorado(data_long4$HUCID_num, c("18040011","18020125","18040012", "18020126", "18020128","18020129", "18040013", '18010122'))))+
  theme(panel.grid = element_blank())+
  theme(legend.position = "none")

ggsave("barplot4.png", plot = map_b4, width = 4, height = 4.5, units = "in", dpi=300)


```
##Figure
```{r}
selection1 <- WatershedBoundaries %>% 
  filter(HUCID %in% c("18040011","18020125","18040012", "18020126", "18020128","18020129", "18040013", '18010122'))


map_q6 <- ggplot() +
    geom_tile(data = bivMapDFQ4, aes(x = x, y = y, fill = bivVal)) +
      scale_fill_gradientn(colours = col.matrixQ4, na.value = "transparent") + 
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA, color = '#939393') +
    geom_sf(data = selection1, fill = NA, lwd = .55) +
    theme_classic() + theme(panel.grid.major = element_blank(),
                            panel.grid.minor = element_blank()) +
    theme(text = element_text(size = 18, colour = "black")) +
    borders(colour = "black", size = 0.1) +
    coord_sf() +
    theme(legend.position = "none",
          plot.background = element_blank(),
          strip.text = element_blank(), 
          #axis.text.y = element_blank(),
          #axis.text = element_blank(),
          axis.title = element_blank())

map_q6 <- map_q6 + inset_element(BivLegend, 0, .1, 0.3, 0.2)

ggsave("map_q6.png", plot = map_q6, width = 7.6, height = 4.69, units = "in", dpi = 300)
```


```{r}
library(Cairo)
png(filename = "map_q6png.png", width = 7.6, height = 4.69, units = "in", type = "cairo", res = 800) 
map_q6
dev.off()
while (!is.null(dev.list()))  dev.off()
```


##post processing 16 colors
```{r}
colMatrix_rasValueshighRiskHighQual %>%
  distinct(rasValue, HEX)

show_col(colMatrix_rasValueshighRiskHighQual$HEX)
#HOOK UP THE COLOR WITH THE  HEX CODE and the  raster number 

#check and see what it looks like
plot(bivmapQ4)
unique(bivmapQ4)


#hook up to watershed boundaries to aggregate by watershed
WatershedBoundaries$bivmap <- exact_extract(bivmapQ4$highRiskHighQual, WatershedBoundaries, 'frac')
WatershedBoundaries$bivmap_mode <- exact_extract(bivmapQ4$highRiskHighQual, WatershedBoundaries, 'mode')
WatershedBoundaries$cat <- ifelse(WatershedBoundaries$bivmap_mode == c(1,2),"neither",ifelse(WatershedBoundaries$bivmap_mode == c(3,4),"water", ifelse(WatershedBoundaries$bivmap_mode == c(17,18),"fire","both")))

palette_biv2 <- colorRampPalette(colors = c("#574249", "#64ACBE", "#E8E8E8", "#C85A5A"))(4)

map_w <- ggplot() +
  geom_sf(data = WatershedBoundaries, aes(fill = cat), na.rm=T) +
  scale_fill_manual(values=palette_biv2) + 
  xlab(NULL)+
  ylab(NULL)+
  #ggtitle(expression(paste("Majority of Area in Watershed"))) + 
  theme_minimal() +
  theme(panel.grid.major = element_line(colour = "transparent")) +
  theme(axis.text.x = element_blank(), axis.text.y = element_blank()) +
  theme(legend.position = "none")
  #theme(plot.title = element_text(hjust = 0.5, size = 12),
          #plot.subtitle = element_text(hjust = 0.5))+
  #theme(panel.border = element_rect(colour = "black", fill=NA))
#So there are no watersheds where the majority of pixels are water (4) or both (1) 
WatershedBoundariesdf4 <- st_drop_geometry(WatershedBoundaries)
WatershedBoundariesdf4$frac_1 <- WatershedBoundariesdf4$bivmap[[1]]
WatershedBoundariesdf4$frac_2 <- WatershedBoundariesdf4$bivmap[[2]]
WatershedBoundariesdf4$frac_3 <- WatershedBoundariesdf4$bivmap[[3]]
WatershedBoundariesdf4$frac_4 <- WatershedBoundariesdf4$bivmap[[4]]
WatershedBoundariesdf4$frac_17<- WatershedBoundariesdf4$bivmap[[5]]
WatershedBoundariesdf4$frac_18 <- WatershedBoundariesdf4$bivmap[[6]]
WatershedBoundariesdf4$frac_19 <- WatershedBoundariesdf4$bivmap[[7]]
WatershedBoundariesdf4$frac_20 <- WatershedBoundariesdf4$bivmap[[8]]



WatershedBoundariesdf4 <- WatershedBoundariesdf4 %>%
  mutate(HUCID_num = as.numeric(sub("^HUC ", "", as.character(HUCID)))) %>% 
  mutate(HUCID_num = as.character(HUCID_num))


data_long4 <- tidyr::pivot_longer(WatershedBoundariesdf4, cols = c(frac_1, frac_2, frac_3, frac_4, frac_17, frac_18, frac_19, frac_20), names_to = "variable", values_to = "percentage")

# Plot
map_b4 <- ggplot(data_long4, aes(x = HUCID_num, y = percentage, fill = variable)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c(
    "frac_1" = "#E8E8E8", 
    'frac_20' = "#574249", 
    "frac_2" = "#BBD3DA", 
    "frac_3" = "#90C0CC", 
    "frac_4" = "#64ACBE", 
    "frac_17" = "#C85a5a", 
    "frac_18" = "#a25254", 
    'frac_19' = "#7c4a4e")) +
  labs(title = "Percentage of watershed in each category",
       x = "HUC ID",
       y = "Percentage") +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+
  theme(panel.grid = element_blank())+
  theme(legend.position = "none"))

ggsave("barplot4.png", plot = map_b4, width = 4, height = 4.5, units = "in")
```




#NDC
##read in CSV


```{r}
ndc <- read.csv("final_results_dissemination_NDINDC.csv")
ndc <- ndc %>% 
  filter(State == "California" | State == "Nevada")
```

```{r}
counties <- counties(c("California", "Nevada"))
plot(counties)

counties <- st_make_valid(counties) %>%
  dplyr::mutate(valid =st_is_valid(counties)) %>% 
  dplyr::filter(valid=="TRUE") 
#^Millie's validation code...use later

counties <- st_transform(counties, 3310)
counties$County <- counties$NAME 
counties$State <- ifelse(counties$STATEFP == "06", "California", "Nevada")

#join
ndc_cty <- left_join(counties, ndc, by = c("County","State"))
```

```{r}
summary(ndc_cty$NDC)
ndcplot <- ggplot() +
   # geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = ndc_cty, aes(fill = NDC), lwd = 0.1) +
     scale_fill_gradient(limits = c(0, 30),
                      oob = scales::squish,
                      labels = c("0", "10", "20", "30+"))+
    theme_minimal()+
    ggtitle(expression(paste("NDC by County"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    #theme(element_text(size=10),legend.position = c(.15,.2))+
    #labs(color = "dams/km", size=10)+
    theme(panel.border = element_rect(colour = "black", fill=NA))

```

```{r}
# Create a fresh area variable for watersheds
WatershedBoundaries <- mutate(WatershedBoundaries, watershed_area = st_area(WatershedBoundaries))
ndc_cty <- mutate(ndc_cty, county_area = st_area(ndc_cty))

# Re-run intersections and calculations to just calculate HUC ndc values
intersect_ndc <- st_intersection(WatershedBoundaries,ndc_cty) %>% 
  mutate(intersect_area = st_area(.)) %>% 
  mutate(coverage = as.numeric(intersect_area/county_area)) %>% 
  mutate(intersect_ndc = coverage * NDC) %>%
  mutate_if(is.numeric, round, 5) %>% 
  dplyr::select(HUCID, intersect_ndc) %>%   
  st_drop_geometry() %>% 
  group_by(HUCID) %>% 
  summarize(huc_ndc = sum(intersect_ndc))


# Merge to watershed boundaries dataset
WatershedBoundaries <- left_join(WatershedBoundaries, intersect_ndc, by = "HUCID")

```
```{r}
summary(WatershedBoundaries$huc_ndc)

hucndc_plot <- ggplot() +
   # geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = WatershedBoundaries, aes(fill = (huc_ndc)), lwd = 0.1) +
    scale_fill_gradient(limits = c(0, 30),
                      oob = scales::squish,
                      labels = c("0", "10", "20", "30+"))+
    theme_minimal()+
    ggtitle(expression(paste("NDC by HUC8"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    #theme(element_text(size=10),legend.position = c(.15,.2))+
    #labs(color = "dams/km", size=10)+
    theme(panel.border = element_rect(colour = "black", fill=NA))

```

##Data wrangling
```{r}
#firerisk_normalized = sum of high fire risk pixels / total pixels 
#firerisk_normalized_Streamshq = sum of fire resilient pixels / pixels along streams 
#huc_ndc = NDC per watershed
#normVol = potential volume storage / total length of streams in watershed


#1: fireRisk_normalized = area of high fire risk pixels / total pixels 
WatershedBoundaries$npixels <- exact_extract(highRisk, WatershedBoundaries, 'count')
WatershedBoundaries$area_m2 <- WatershedBoundaries$npixels*270*270  
WatershedBoundaries$area_km2 <- round(WatershedBoundaries$area_m2/1e6,2)
WatershedBoundaries$total_area <- as.numeric(st_area(WatershedBoundaries))
WatershedBoundaries$total_area_km2 <- round(WatershedBoundaries$total_area/1e6,2)
WatershedBoundaries$firerisk_normalized <- WatershedBoundaries$area_m2 / WatershedBoundaries$total_area



#2: firerisk_normalized_Streamshq = area of fire resilient pixels / pixels along streams 
#High fire risk pixels along streams
highRisk_Streams <- extract(highRisk, AllSierras_DamCapacity, xy = TRUE, touches = TRUE, na.rm=T)
highRisk_Streams <- highRisk_Streams[,c(3,4,2)] #reorder for Rast function
highRisk_Streams <- highRisk_Streams[complete.cases(highRisk_Streams), ]
highRisk_Streams <- rast(highRisk_Streams, type = 'xyz')
wkt <- crs(contFireRisk)
crs(highRisk_Streams) <- wkt
plot(highRisk_Streams)
#make sure it's the right size
highRisk_Streams <- extend(highRisk_Streams, contFireRisk)
#extract to watersheds
WatershedBoundaries$npixels_Streams <- exact_extract(highRisk_Streams, WatershedBoundaries, 'count')
WatershedBoundaries$area_m2_Streams <- WatershedBoundaries$npixels_Streams*270*270  
WatershedBoundaries$area_km2_Streams <- round(WatershedBoundaries$area_m2_Streams/1e6,2)


#High fire risk pixels along high quality streams
highRisk_Streamshq <- extract(highRisk, highquality, xy = TRUE, touches = TRUE)
highRisk_Streamshq <- highRisk_Streamshq[,c(3,4,2)] #reorder for Rast function
highRisk_Streamshq <- highRisk_Streamshq[complete.cases(highRisk_Streamshq), ]
highRisk_Streamshq <- rast(highRisk_Streamshq, type = 'xyz')
wkt <- crs(contFireRisk)
crs(highRisk_Streamshq) <- wkt
plot(highRisk_Streamshq)
#make sure it's the right size
highRisk_Streamshq <- extend(highRisk_Streamshq, contFireRisk)
#extract to watersheds
WatershedBoundaries$npixels_Streamshq <- exact_extract(highRisk_Streamshq, WatershedBoundaries, 'count')
WatershedBoundaries$area_m2_Streamshq <- WatershedBoundaries$npixels_Streams*270*270  
WatershedBoundaries$area_km2_Streamshq <- round(WatershedBoundaries$area_m2_Streams/1e6,2)
WatershedBoundaries$firerisk_normalized_Streamshq <- WatershedBoundaries$area_m2_Streamshq / WatershedBoundaries$total_area



#Normalized volume / stream km
AllSierras_DamCapacity$VolumePerKm <-  AllSierras_DamCapacity$volume/((AllSierras_DamCapacity$iGeo_Len)*0.001)
watersheds <- st_join(WatershedBoundaries,AllSierras_DamCapacity)

watersheds <- st_drop_geometry(watersheds)

watershedstest <- watersheds %>%
    group_by(HUCID) %>% 
    summarise(normVol = mean(VolumePerKm), 
              meanDamCap = mean(oCC_EX),
              meanHistDamCap = mean(oCC_HPE),
              meanHistRemain = mean(mCC_EXvHPE, na.rm=T)) 

WatershedBoundaries <- merge(WatershedBoundaries, watershedstest, by = "HUCID")
watershed_csv <- st_drop_geometry(WatershedBoundaries)
write.csv(watershed_csv, "watershed_csv.csv", row.names = TRUE)
saveRDS(WatershedBoundaries,"WatershedBoundaries.rds")
WatershedBoundaries <- readRDS('WatershedBoundaries.rds')
```


##Visualize the future
```{r}
huc_ndc_plot <- ggplot() +
   # geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = WatershedBoundaries, aes(fill = (huc_ndc)), lwd = 0.1) +
    scale_fill_gradient(limits = c(0, 30),
                      oob = scales::squish,
                      labels = c("0", "10", "20", "30+"))+
    theme_minimal()+
    ggtitle(expression(paste("Water Deficit (NDC)"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    #theme(element_text(size=10),legend.position = c(.15,.2))+
    #labs(color = "dams/km", size=10)+
    theme(panel.border = element_rect(colour = "black", fill=NA))


normVol_plot <- ggplot() +
  geom_sf(data = WatershedBoundaries) +
  geom_sf(data = watersheds, aes(fill = normVol), inherit.aes = FALSE) +
  scale_fill_viridis_c(option = "plasma") + 
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("Potential Water Storage (m3/km)"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
  theme(panel.border = element_rect(colour = "black", fill=NA))


firerisk_normalized_plot <- ggplot() +
   # geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = WatershedBoundaries, aes(fill = (firerisk_normalized)), lwd = 0.1) +
    scale_fill_viridis_c(option = 'inferno', limits = c(0,0.6)) +
    theme_minimal()+
    ggtitle(expression(paste("% Area High Fire Risk"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    #theme(element_text(size=10),legend.position = c(.15,.2))+
    #labs(color = "dams/km", size=10)+
    theme(panel.border = element_rect(colour = "black", fill=NA))

firerisk_normalized_Streamshq_plot <- ggplot() +
   # geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = WatershedBoundaries, aes(fill = (firerisk_normalized_Streamshq)), lwd = 0.1) +
    scale_fill_viridis_c(option = 'inferno',limits = c(0,0.6)) +
    theme_minimal()+
    ggtitle(expression(paste("% Area High-Risk-High-Capacity"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    #theme(element_text(size=10),legend.position = c(.15,.2))+
    #labs(color = "dams/km", size=10)+
    theme(panel.border = element_rect(colour = "black", fill=NA))
```

```{r}
(huc_ndc_plot +normVol_plot) / (firerisk_normalized_plot +firerisk_normalized_Streamshq_plot)
```

```{r}
firerisk_normalized_Streamshq_plot <- ggplot() +
   # geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = WatershedBoundaries, aes(fill = (firerisk_normalized_Streamshq)), lwd = 0.1) +
    scale_fill_gradient(low = "#e8e8e8", high ="#c85a5a", name = "% of High \nRisk Areas")+
    theme_minimal()+
    ggtitle(expression(paste("Potential Fire Resilience"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
  theme(legend.text = element_text(size=7),
          legend.title = element_text(size = 7),
          legend.position = c(.2,.20),
          legend.key.size = unit(.8, "lines"),
          legend.title.align= 0.5)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    #theme(element_text(size=10),legend.position = c(.15,.2))+
    #labs(color = "dams/km", size=10)+
    theme(panel.border = element_rect(colour = "black", fill=NA))

firerisk_plot <- ggplot() +
   # geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = WatershedBoundaries, aes(fill = (firerisk_normalized_Streamshq)), lwd = 0.1) +
    scale_fill_gradient(low = "#e8e8e8", high ="#FFA500", name = "% Area\nWHP>2000")+
    theme_minimal()+
    ggtitle(expression(paste("Fire Risk"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
   theme(legend.text = element_text(size=7),
          legend.title = element_text(size = 7),
          legend.position = c(.2,.20),
          legend.key.size = unit(.8, "lines"),
          legend.title.align= 0.5)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    #theme(element_text(size=10),legend.position = c(.15,.2))+
    #labs(color = "dams/km", size=10)+
    theme(panel.border = element_rect(colour = "black", fill=NA))

normVol_plot <- ggplot() +
  geom_sf(data = WatershedBoundaries) +
  geom_sf(data = WatershedBoundaries, aes(fill = normVol), inherit.aes = FALSE) +
  scale_fill_gradient(low = "#e8e8e8", high = "#64abce", name = "Potential Water \nStorage (m3/km)")+
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("Potential Water Storage"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) + 
  theme(legend.text = element_text(size=7),
          legend.title = element_text(size = 7),
          legend.position = c(.2,.20),
          legend.key.size = unit(.8, "lines"),
          legend.title.align= 0.5)+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
  theme(panel.border = element_rect(colour = "black", fill=NA))

ndcblue_plot <- ggplot() +
  geom_sf(data = WatershedBoundaries) +
  geom_sf(data = WatershedBoundaries, aes(fill = huc_ndc.x), inherit.aes = FALSE) +
  scale_fill_gradient(low = "#e8e8e8", high = "#73ae80", name = "NDC", 
                      limits = c(0, 30),
                      oob = scales::squish,
                      labels = c("0", "10", "20", "30+"))+
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("Water Deficit (NDC)"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) + 
  theme(legend.text = element_text(size=7),
          legend.title = element_text(size = 7),
          legend.position = c(.2,.20),
          legend.key.size = unit(.8, "lines"),
          legend.title.align= 0.5)+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
  theme(panel.border = element_rect(colour = "black", fill=NA))
```

```{r}
 (ndcblue_plot + normVol_plot) / (firerisk_plot + firerisk_normalized_Streamshq_plot)
 ndcblue_plot + normVol_plot + firerisk_plot + firerisk_normalized_Streamshq_plot

```


##Make a scatterplot
```{r}
summary(WatershedBoundaries$firerisk_normalized)
#mean = 0.2
x_value <- 0.2
y_value = 1

#Vertical black line represents % high fire risk = 0.2, which is the mean
#horizontal black line represents NDC <1, indicating watersheds with no water deficit
ggplot()+
  geom_point(data = WatershedBoundaries, aes(x = firerisk_normalized, y = (huc_ndc.x), size = normVol, color = firerisk_normalized_Streamshq))+ 
  geom_vline(xintercept = x_value, color = "black", linetype = "solid") +
  geom_hline(yintercept = y_value, color = "black", linetype = "solid") +
  #geom_text(data = WatershedBoundaries, aes(x = firerisk_normalized, y = huc_ndc, label = HUCID), vjust = -1.5, size = 2) +
  geom_text_repel(data = WatershedBoundaries, aes(x = firerisk_normalized, y = huc_ndc.x, label = HUCID), size = 2)+
  theme_minimal()+
  scale_color_gradient(low = "#e8e8e8", high ="#c85a5a", name = "Potential % Area \nw/ Fire Resilience")+
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE), trans = "log10")+
  ggtitle(expression(paste("Water Deficit vs. Fire Risk"))) +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    #theme(element_text(size=10),legend.position = c(.15,.2))+
  labs(x = "% Watershed Area with High Fire Risk",
       y = "Watershed-scale Water Deficit (NDC)", 
       size = "Potential Water \nStorage")+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
  theme(panel.border = element_rect(colour = "black", fill=NA))  
```
```{r}
selection <- WatershedBoundaries %>% 
  filter(HUCID %in% c("16050201","18040012","18040010", "18040013", "18020126","18020129", "18020125", "18040008", "18030001", "16050102"))

summary(selection$normVol)
summary(selection$firerisk_normalized_Streamshq   )


ndc_selection <- ggplot() +
   # geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = WatershedBoundaries, fill = NA, lwd = 0.1) +
    geom_sf(data = selection, aes(fill = normVol), lwd = .6) +
    scale_fill_gradient(low = "#e8e8e8", high = "#64abce", name = "Potential Water Storage \n(m3/km)")+
    theme_minimal()+
    #ggtitle(expression(paste("Potential Water Storage"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5),
          legend.key.size = unit(1, "lines")) +
    theme(legend.text = element_text(size=8),
          legend.title = element_text(size = 8),
          legend.position = c(.2,.20),
          legend.title.align= 0.5)+
    #labs(color = "dams/km", size=10)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.grid.major = element_line(colour = "transparent")) +
    theme(axis.text.x = element_blank(), axis.text.y = element_blank()) 
   # theme(panel.border = element_rect(colour = "black", fill=NA))

fire_selection <- ggplot() +
   # geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = WatershedBoundaries, fill = NA, lwd = 0.1) +
    geom_sf(data = selection, aes(fill = firerisk_normalized_Streamshq), lwd = .6) +
    scale_fill_gradient(low = "#e8e8e8", high ="#c85a5a", name = "Potential Fire Resilience \n(% of high risk areas)")+
    theme_minimal()+
    #ggtitle(expression(paste("Potential Fire Resilience"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5),
          legend.key.size = unit(1, "lines")) +
    theme(legend.text = element_text(size=8),
          legend.title = element_text(size = 8),
          legend.position = c(.2,.20),
          legend.title.align= 0.5)+
    #labs(color = "dams/km", size=10)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.grid.major = element_line(colour = "transparent")) +
    theme(axis.text.x = element_blank(), axis.text.y = element_blank()) 
   # theme(panel.border = element_rect(colour = "black", fill=NA))

(ndc_selection + fire_selection)
```
##Maybe doent do it with a selection ?
```{r}
ndc_selection2 <- ggplot() +
   # geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = WatershedBoundaries, aes(fill = normVol), lwd = 0.1) +
    geom_sf(data = selection, fill = NA, lwd = .6, color = "black") +
    scale_fill_gradient(low = "#e8e8e8", high = "#64abce", name = "Potential Water Storage \n(m3/km)")+
    theme_minimal()+
    #ggtitle(expression(paste("Potential Water Storage"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5),
          legend.key.size = unit(1, "lines")) +
    theme(legend.text = element_text(size=8),
          legend.title = element_text(size = 8),
          legend.position = c(.2,.20),
          legend.title.align= 0.5)+
    #labs(color = "dams/km", size=10)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.grid.major = element_line(colour = "transparent")) +
    theme(axis.text.x = element_blank(), axis.text.y = element_blank()) 
   # theme(panel.border = element_rect(colour = "black", fill=NA))

fire_selection2 <- ggplot() +
   # geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = WatershedBoundaries, aes(fill = firerisk_normalized_Streamshq), lwd = 0.1) +
    geom_sf(data = selection, fill = NA, lwd = .6, color = "black") +
    scale_fill_gradient(low = "#e8e8e8", high ="#c85a5a", name = "Potential Fire Resilience \n(% of high risk areas)")+
    theme_minimal()+
    #ggtitle(expression(paste("Potential Fire Resilience"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5),
          legend.key.size = unit(1, "lines")) +
    theme(legend.text = element_text(size=8),
          legend.title = element_text(size = 8),
          legend.position = c(.2,.20),
          legend.title.align= 0.5)+
    #labs(color = "dams/km", size=10)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.grid.major = element_line(colour = "transparent")) +
    theme(axis.text.x = element_blank(), axis.text.y = element_blank()) 
   # theme(panel.border = element_rect(colour = "black", fill=NA))

(ndc_selection2 + fire_selection2)
```

