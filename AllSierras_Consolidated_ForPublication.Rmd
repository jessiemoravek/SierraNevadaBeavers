---
title: "AllSierras_Consolidated_ForPublication"
output: html_document
---

```{r include=FALSE}
library(tidyverse)
library(ggplot2)
library(dplyr)
library(dataRetrieval)
library(sf)
library(maps)
library(sp)
library(ncdf4)
library(sf)
library(sp)
library(lwgeom)
library(terra)
library(raster)
library(mapview)
library(tidyterra)
library(viridis)
library(MetBrewer)
library(data.table)
library(tigris)
library(patchwork)
library(car)
library(multcomp)
library(exactextractr)
library(scales)
library(ggrepel)
library(terra)
```

#Input Files (pre-processed as .rds files)
```{r}
#BRAT model results for all 31 study watersheds
AllSierras_DamCapacity <- readRDS("AllSierras_DamCapacity_volume.rds")


#State boundaries map for figure backgrounds
#United States Census Bureau. 2023. “TIGER/Line® Shapefiles.” Shapefile dataset. https://www.census.gov/cgi-bin/geo/shapefiles/index.php.
background <- readRDS("background.rds")


#Watershed boundaries map for figure backgrounds
#U.S. Geological Survey. 2024b. “National Hydrography Dataset.” 2024. https://www.usgs.gov/national-hydrography/national-hydrography-dataset.
WatershedBoundaries <- readRDS("WatershedBoundaries.rds")


#Wildfire Hazard Potential (WHP) 
#U.S. Forest Service. 2020. “Wildfire Hazard Potential | Missoula Fire Sciences Laboratory.” USDA Forest Service, Fire Modeling Institute. https://research.fs.usda.gov/firelab/products/dataandtools/wildfire-hazard-potential.
contFireRisk <- readRDS("contFireRisk.rds")


#Land ownership (public vs. private land)
#BLM National SMA Surface Management Agency Area Polygons. 2024. US Department of the Interior Bureau of Land Management. April 18, 2024. https://gbp-blm-egis.hub.arcgis.com/datasets/6bf2e737c59d4111be92420ee5ab0b46/about.
landownership <- readRDS("landownership.rds")
```


#Read in Input Files (not pre-processed)
##Dam Capacity
```{r}
#BRAT model results for all 31 study watersheds

# Read in the shapefile with st_read()
AllSierras_DamCapacity <- st_read("C:/Users/morav042/Documents/SierraNevadaBeavers/AllSierras_DamCapacity6.shp")

#remove unneeded shapefiles
file.remove(list.files(pattern = "AllSierras_DamCapacity*",recursive = F))

#Project to California Teal Albers 2011 (Meters) (EPSG:3310)
AllSierras_DamCapacity <- st_transform(AllSierras_DamCapacity, 3310)

saveRDS(AllSierras_DamCapacity,"AllSierras_DamCapacity.rds")

```

##WatershedBoundaries
```{r}
#Watershed boundaries map for figure backgrounds
#U.S. Geological Survey. 2024b. “National Hydrography Dataset.” 2024. https://www.usgs.gov/national-hydrography/national-hydrography-dataset.

# Read in the shapefile with st_read()
WatershedBoundaries <- st_read("C:/Users/morav042/Documents/SierraNevadaBeavers/WatershedBoundaries5.shp")

#remove unneeded shapefiles
file.remove(list.files(pattern = "WatershedBoundaries*",recursive = F))

#Project to California Teal Albers 2011 (Meters) (EPSG:3310)
WatershedBoundaries <- st_transform(WatershedBoundaries, 3310)

saveRDS(WatershedBoundaries,"WatershedBoundaries.rds")
```

##Fire Risk 
```{r}
#Wildfire Hazard Potential (WHP) 
#U.S. Forest Service. 2020. “Wildfire Hazard Potential | Missoula Fire Sciences Laboratory.” USDA Forest Service, Fire Modeling Institute. https://research.fs.usda.gov/firelab/products/dataandtools/wildfire-hazard-potential.

#Read in the raster 
contFireRisk <- rast("C:/Users/morav042/Documents/SierraNevadaBeavers/FireRisk/FireRisk_4.tif")

#Project to California Teal Albers 2011 (Meters) (EPSG:3310)
contFireRisk <- project(contFireRisk, crs(AllSierras_DamCapacity))
crs(contFireRisk) == crs(AllSierras_DamCapacity) #Double check projection

#Crop
contFireRisk <- crop(contFireRisk, WatershedBoundaries)
contFireRisk <- mask(contFireRisk, WatershedBoundaries)

plot(contFireRisk)

saveRDS(contFireRisk,"contFireRisk.rds")

```

##LandOwnership
```{r}
#Land ownership (public vs. private land)
#BLM National SMA Surface Management Agency Area Polygons. 2024. US Department of the Interior Bureau of Land Management. April 18, 2024. https://gbp-blm-egis.hub.arcgis.com/datasets/6bf2e737c59d4111be92420ee5ab0b46/about.

# Read in the shapefile with st_read()
landownership <- st_read("C:/Users/morav042/Documents/SierraNevadaBeavers/LandOwnership.shp")

#remove unneeded shapefiles
file.remove(list.files(pattern = "LandOwnership*",recursive = F))

#Project to California Teal Albers 2011 (Meters) (EPSG:3310)
landownership <- st_transform(landownership, 3310)
crs(AllSierras_DamCapacity) ==crs(landownership)

saveRDS(landownership,"landownership.rds")
```

##Water Deficit
```{r}
#Water Deficit
#Devineni, Naresh, Upmanu Lall, Elius Etienne, Daniel Shi, and Chen Xi. 2015. “America’s Water Risk: Current Demand and Climate Variability.” Geophysical Research Letters 42 (7): 2285–93. https://doi.org/10.1002/2015GL063487.

#Read in csv
ndc <- read.csv("final_results_dissemination_NDINDC.csv")

#Filter by state
ndc <- ndc %>% 
  filter(State == "California" | State == "Nevada")
```



#Surface water storage Analysis
##Volume calculation
```{r}
for (i in AllSierras_DamCapacity){ #for each stream segment in the BRAT model output shapefile
  damCt <- AllSierras_DamCapacity$mCC_EX_CT #number of beaver dams per segment (calculated based on dam density and segment length as the column mCC_EX_CT in the attribute table)
  slope <- AllSierras_DamCapacity$iGeo_Slope #meters
  da <- AllSierras_DamCapacity$iGeo_DA #m2
  width <- ifelse(da < 4.95,2.18*(da)^0.191,
                  ifelse(da >= 4.95 & da < 377,1.41*(da)^0.462,7.18*(da)^0.183)) #based on Scamardo et al. 2022
  height <- 1 #assume all beaver dams are 1m tall
  length <- height/slope #trigonometry: slope = rise/run, so run = rise/slope
  maxLength<- (AllSierras_DamCapacity$iGeo_Len/damCt) #set a maximum length so that we can change volume calculations if there are so many dams that they all run together
  volume <- ifelse(length < maxLength, 0.5*(height)*(width)*(length)*(damCt),(height)*(width)*(maxLength)*(damCt))
  surfaceArea <- ifelse(length < maxLength, (width)*(length)*(damCt),(width)*(maxLength)*(damCt))
  AllSierras_DamCapacity$width <- width
  AllSierras_DamCapacity$volume <- volume #m3
  AllSierras_DamCapacity$surfaceArea <- surfaceArea #m2
} 
```

##Calculate Historical Percent Remaining
```{r}
AllSierras_DamCapacity$mCC_EXvHPE <- AllSierras_DamCapacity$oCC_EX/AllSierras_DamCapacity$oCC_HPE
#When doing this division, sometimes we get 0/0 = Inf, especially in areas that are slope limited. We converted these to NA values below: 

AllSierras_DamCapacity$mCC_EXvHPE[!is.finite(AllSierras_DamCapacity$mCC_EXvHPE)] <- NA
```

##Change in veg suitability
```{r}
AllSierras_DamCapacity$VegChange100 <-  AllSierras_DamCapacity$iVeg100EX - AllSierras_DamCapacity$iVeg100Hpe 
```

##Historical volume calculation
```{r}
for (i in AllSierras_DamCapacity){ #for each stream segment in the BRAT model output shapefile
  damCt <- AllSierras_DamCapacity$mCC_HPE_CT #number of beaver dams per segment (calculated based on dam density and segment length as the column mCC_HPE_CT in the attribute table)
  slope <- AllSierras_DamCapacity$iGeo_Slope #meters
  da <- AllSierras_DamCapacity$iGeo_DA #m2
  width <- ifelse(da < 4.95,2.18*(da)^0.191,
                  ifelse(da >= 4.95 & da < 377,1.41*(da)^0.462,7.18*(da)^0.183)) #based on Scamardo et al. 2022
  height <- 1 #assume all beaver dams are 1m tall
  length <- height/slope #trigonometry: slope = rise/run, so run = rise/slope
  maxLength<- (AllSierras_DamCapacity$iGeo_Len/damCt) #set a maximum length so that we can change volume calculations if there are so many dams that they all run together
  volumeHist <- ifelse(length < maxLength, 0.5*(height)*(width)*(length)*(damCt),(height)*(width)*(maxLength)*(damCt))
  surfaceAreaHist <- ifelse(length < maxLength, (width)*(length)*(damCt),(width)*(maxLength)*(damCt))
  AllSierras_DamCapacity$width <- width
  AllSierras_DamCapacity$volumeHist <- volumeHist #m3
  AllSierras_DamCapacity$surfaceAreaHist <- surfaceAreaHist #m2
} 

```

##Volume Change
```{r}
AllSierras_DamCapacity$VolumeChange <-  AllSierras_DamCapacity$volume - AllSierras_DamCapacity$volumeHist

```

##Normalizing volume
```{r}
AllSierras_DamCapacity$VolumePerKm <-  AllSierras_DamCapacity$volume/((AllSierras_DamCapacity$iGeo_Len)*0.001)

```

##Save
```{r}
saveRDS(AllSierras_DamCapacity,"AllSierras_DamCapacity_volume.rds")

```


#Descriptive Figures
##Figure 2 Inset
```{r}
#Palette
pal3 <- (hcl.colors(5,"plasma"))

#Watershed + State boundaries
w <- ggplot() +
    geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = WatershedBoundaries, fill = "#939393", lwd = 0.1, alpha = 0.5 ) +
    ggtitle(expression(paste("Watershed Boundaries"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.border = element_rect(colour = "black", fill=NA))+
    theme_classic()

ggsave("Fig_watershedboundaries.png", plot = w, width = 6.8, height = 8, units = "in", bg = "white", dpi=300)

```
##Figure 2a: Historical Dam Capacity Map
```{r}
h <- ggplot() +
  geom_sf(data = transform(AllSierras_DamCapacity, DamCapacity = cut(oCC_HPE, breaks = c(0, .1, 2, 5, 15, 40), include.lowest = TRUE)), aes(color = DamCapacity), lwd= 0.3) +
  geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
  scale_color_manual(values = pal3, labels = c("0", "1-2", "2-5", "5-15", "15-40")) +
  theme_minimal() +
  ggtitle(expression(paste("Historical Dam Capacity"))) +
  theme(
    plot.title = element_text(hjust = 1, size = 12),
    plot.subtitle = element_text(hjust = 0.5),
    legend.text = element_text(size = 8),
    legend.title = element_text(size = 8),
    legend.position = c(0.2, 0.20),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),  # Remove default panel border
    axis.line.x = element_line(color = "black"),  # Add border to x axis
    axis.line.y = element_line(color = "black")   # Add border to y axis
  ) +
  labs(color = "dams/km", size = 10)

```

##Figure 2b: Current Dam Capacity Map
```{r}
c <- ggplot() +
    geom_sf(data = transform(AllSierras_DamCapacity, DamCapacity=cut(oCC_EX, breaks = c(0,.1,2,5,15,40), include.lowest=T)),aes(color = DamCapacity), lwd= 0.3) +
   geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
    scale_color_manual(values=pal3, labels = c("0", "1-2", "2-5", "5-15", "15-40"))+
    theme_minimal()+
    ggtitle(expression(paste("Current Dam Capacity"))) +
    theme(plot.title = element_text(hjust = 1, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    theme(legend.text = element_text(size=8),
          legend.title = element_text(size = 8),
          legend.position = c(.2,.20))+
     labs(color = "dams/km", size=10)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.grid.major = element_line(colour = "transparent")) +
    theme(axis.text.x = element_blank(), axis.text.y = element_blank()) 

```

##Fibure 2c: Percent Remaining Map
```{r}
r <- ggplot() +
    geom_sf(data = transform(AllSierras_DamCapacity, DamCapacity=cut(mCC_EXvHPE, breaks = c(0,.25,.5,.75,1,70), include.lowest=T)),aes(color = DamCapacity), lwd=0.3) +
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
    scale_color_manual(values=pal3,
                        labels = c("0", "1 - 25%", "26 - 50%", "51 - 75%", "76 - 100+%", "NA"))+
    theme_minimal()+
    ggtitle(expression(paste("% Capacity Remaining"))) +
    theme(plot.title = element_text(hjust = 1, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    theme(legend.text = element_text(size=8),
          legend.title = element_text(size = 8),
          legend.position = c(.2,.20))+
    labs(color = "% remaining", size=10)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.grid.major = element_line(colour = "transparent")) +
    theme(axis.text.x = element_blank(), axis.text.y = element_blank()) 

```

##Figure 2 Layout
```{r}
fig2 <- h+c+r
fig2_abc <- fig2 + plot_annotation(tag_levels = 'A')

ggsave("Fig_damcaphist.png", plot = fig2_abc, width = 7, height = 4.32, units = "in", bg = "white", dpi=900)
##Inset added in photoshop
```

##Appendix 1: Figure S1: Fire Risk WHP 
```{r}
whp_plasma <- ggplot() +
    geom_tile(data = contFireRisk, aes(x = x, y = y, fill = Band_1)) +
    scale_fill_viridis("WHP",option = "C", na.value = "transparent") + 
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA, color = '#939393') +
    theme_classic() + theme(panel.grid.major = element_blank(),
                            panel.grid.minor = element_blank()) +
    theme(text = element_text(size = 10, colour = "black")) +
    borders(colour = "black", size = 0.1) +
    coord_sf() +
    ggtitle(expression(paste("WHP"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    labs(color = contFireRisk, size=10)
   
ggsave("Fig_firerisk.png", plot = whp_plasma, width = 7, height = 4.32, units = "in", bg = "white", dpi=900) 
```

##Appendix 1: Figure S2: Change in veg suitability 
```{r}
veg <- ggplot() +
    geom_sf(data = AllSierras_DamCapacity, aes(color = VegChange100)) +
    scale_color_gradient2(low = "red", mid = "white", high = "blue", midpoint = 0, na.value = "grey70")+
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
    xlab(NULL)+
    ylab(NULL)+
    ggtitle(expression(paste("Vegetation Change"))) + 
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 12),
      plot.subtitle = element_text(hjust = 0.5),
      legend.text = element_text(size = 8),
      legend.title = element_text(size = 8),
      legend.position = c(0.2, 0.20),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),  # Remove default panel border
      axis.line.x = element_line(color = "black"),  # Add border to x axis
      axis.line.y = element_line(color = "black")   # Add border to y axis
  ) +
  labs(color = "dams/km", size = 10)

ggsave("Fig_vegchange.png", plot = veg, width = 7, height = 4.32, units = "in", bg = "white", dpi=900)

```


#Fire Risk Analysis
##Extract fire risk to places with dams (stream network)
```{r}
fireDamExtract <- extract(contFireRisk, AllSierras_DamCapacity, xy = TRUE, touches = TRUE)

```


##Fire risk intersection with high quality dam areas
###Pull high quality areas
```{r}
highquality <- subset(AllSierras_DamCapacity, oCC_EX >= 5) #pull out good habitat

```


###Pull high fire risk pixels
```{r}
#Note: We are using the top quartile as high and very high risk areas
summary(contFireRisk$Band_1)
#Top quartile starts at 1361, so let's start at WHP = 2000 as a conservative estimate of high and very high risk areas. 

highRisk <- contFireRisk
highRisk[highRisk[] < 2000] = NA 

```

###Extract high risk and high quality overlap
```{r}
riskExtract <- extract(highRisk, highquality, xy = TRUE, touches = TRUE)
riskExtract <- riskExtract[,c(3,4,2)] #reorder for Rast function
riskExtract <- rast(riskExtract, type = 'xyz')
wkt <- crs(contFireRisk)
crs(riskExtract) <- wkt

hq <- ggplot() +
  geom_spatraster(data = riskExtract, aes(fill = Band_1)) +
  scale_fill_viridis_c(option = "inferno",na.value = "transparent") +
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("High Fire Risk and High Dam Capacity"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5))+
  theme(panel.border = element_rect(colour = "black", fill=NA))

result <- as.data.frame(riskExtract) %>%
  summarise(pixels = n()) %>% 
  mutate(`area m^2` = pixels * 270 * 270, #multiply by pixel area
         `area km^2` = round(`area m^2`/1e6,2)) 
```

#Intermittent Streams
##Assign Perennial
```{r}
#Intermittent assigned in pre-processing

AllSierras_DamCapacity$Flow <- ifelse(is.na(AllSierras_DamCapacity$Flow), "perennial", AllSierras_DamCapacity$Flow)

```

##Appendix 1: Table S3: Calculate Percentages of intermittency
```{r}
#% of total stream km
intermittent <- AllSierras_DamCapacity %>% 
  filter(Flow == "intermittent") 
intermittent_length <- sum(intermittent$iGeo_Len) #m
total_length <- sum(AllSierras_DamCapacity$iGeo_Len)
pct_total_intermittent <- intermittent_length/total_length

#% of 0 dams/km
zero <- AllSierras_DamCapacity %>% 
  filter(oCC_EX == 0) 
pct_zero_intermittent = (sum(zero$Flow == "intermittent"))/(nrow(zero))

zero_intermittent_len <- intermittent %>% 
  filter(oCC_EX == 0) 
zero_intermittent_len <- sum(zero_intermittent_len$iGeo_Len) #m
pct_zero_intermittent_len <- zero_intermittent_len/total_length


#% of 1-2 dams/km
one_two <- AllSierras_DamCapacity %>% 
  filter(oCC_EX >= 1 & oCC_EX <= 2) 
pct_one_two_intermittent = (sum(one_two$Flow == "intermittent"))/(nrow(one_two))

one_two_intermittent_len <- intermittent %>% 
  filter(oCC_EX >= 1 & oCC_EX <= 2) 
one_two_intermittent_len <- sum(one_two_intermittent_len$iGeo_Len) #m
pct_one_two_intermittent_len <- one_two_intermittent_len/total_length


#% of 2-5 dams/km
two_five <- AllSierras_DamCapacity %>% 
  filter(oCC_EX > 2 & oCC_EX <= 5) 
pct_two_five_intermittent = (sum(two_five$Flow == "intermittent"))/(nrow(two_five))

two_five_intermittent_len <- intermittent %>% 
  filter(oCC_EX > 2 & oCC_EX <= 5) 
two_five_intermittent_len <- sum(two_five_intermittent_len$iGeo_Len) #m
pct_two_five_intermittent_len <- two_five_intermittent_len/total_length


#% of 5-15 dams/km
five_fifteen <- AllSierras_DamCapacity %>% 
  filter(oCC_EX > 5 & oCC_EX <= 15) 
pct_five_fifteen_intermittent = (sum(five_fifteen$Flow == "intermittent"))/(nrow(five_fifteen))

five_fifteen_intermittent_len <- intermittent %>% 
  filter(oCC_EX > 5 & oCC_EX <= 15) 
five_fifteen_intermittent_len <- sum(five_fifteen_intermittent_len$iGeo_Len) #m
pct_five_fifteen_intermittent_len <- five_fifteen_intermittent_len/total_length


#% of 15-40 dams/km
fifteen_forty <- AllSierras_DamCapacity %>% 
  filter(oCC_EX > 15 & oCC_EX <= 40) 
pct_fifteen_forty_intermittent = (sum(fifteen_forty$Flow == "intermittent"))/(nrow(fifteen_forty))

fifteen_forty_intermittent_len <- intermittent %>% 
  filter(oCC_EX > 15 & oCC_EX <= 40) 
fifteen_forty_intermittent_len <- sum(fifteen_forty_intermittent_len$iGeo_Len) #m
pct_fifteen_forty_intermittent_len <- fifteen_forty_intermittent_len/total_length

```

##Appendix 1: Figure S3: Intermittent Dam Capacity Map
```{r}
ci <- ggplot() +
    geom_sf(data = transform(intermittent, DamCapacity=cut(oCC_EX, breaks = c(0,.1,2,5,15,40), include.lowest=T)),aes(color = DamCapacity)) +
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
    scale_color_manual(values=pal3,
                        labels = c("0", "1-2", "2-5", "5-15", "15-40"))+
    theme_minimal()+
    ggtitle(expression(paste("Intermittent Stream Dam Capacity"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    theme(legend.text = element_text(size=8),
          legend.title = element_text(size = 8),
          legend.position = c(.2,.20))+
    labs(color = "dams/km", size=10)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.border = element_rect(colour = "black", fill=NA))

ggsave("Fig_intermittent.png", plot = ci, width = 7, height = 4.32, units = "in", bg = "white", dpi=900)
```

##Appendix 1: Table S3: Total percent intermittent water storage
```{r}
intermittent_water <- sum(intermittent$volume) #m
total_water <- sum(AllSierras_DamCapacity$volume)
pct_water_intermittent <- intermittent_water/total_water 

```

##Appendix 1: Figure S3: Ppercent intermittent fire resilience
```{r}
##pull high quality areas
highquality_int <- subset(intermittent, oCC_EX >= 5) #pull out good habitat

#pull high risk areas (from above)
riskExtract_int <- extract(highRisk, highquality_int, xy = TRUE, touches = TRUE)
riskExtract_int <- riskExtract_int[,c(3,4,2)] #reorder for Rast function
riskExtract_int <- rast(riskExtract_int, type = 'xyz')
wkt <- crs(contFireRisk)
crs(riskExtract_int) <- wkt

#Plot high risk-high quality areas with intermittency
hqi <- ggplot() +
  geom_spatraster(data = riskExtract_int, aes(fill = Band_1)) +
  scale_fill_viridis_c(option = "inferno",na.value = "transparent") +
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("High Fire Risk and High Dam Capacity"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5))+
  theme(panel.border = element_rect(colour = "black", fill=NA))


result_int <- as.data.frame(riskExtract_int) %>%
  summarise(pixels = n()) %>% 
  mutate(`area m^2` = pixels * 270 * 270, #multiply by pixel area
         `area km^2` = round(`area m^2`/1e6,2)) 

intermittent_fire <- sum(result_int$`area km^2`) #m
total_fire <- sum(result$`area km^2`)
pct_fire_intermittent <- intermittent_fire/total_fire 

```


#Bivariate Colorpleth Map
##Function producing color matrix (from Chapman et al. 2023)
```{r}
# The function that produces the colour matrix
colmat <- function(nbreaks = 3, breakstyle = "quantile",
                   upperleft = "#279dba", upperright = "#473239", 
                   bottomleft = "#d4d4d4", bottomright = "#c94040",
                   xlab = "x label", ylab = "y label", plotLeg = TRUE,
                   saveLeg = FALSE) {
   # TODO - replace any tidyr, dplyr etc. functions with data.table #
  library(tidyverse)
  require(ggplot2)
  require(classInt)
  library(data.table)
  if (breakstyle == "sd") {
    warning("SD breaks style cannot be used.\nWill not always return the correct number of breaks.\nSee classInt::classIntervals() for details.\nResetting to quantile",
            call. = FALSE, immediate. = FALSE)
    breakstyle <- "quantile"}
  # The colours can be changed by changing the HEX codes for:
  # upperleft, upperright, bottomleft, bottomright
  # From http://www.joshuastevens.net/cartography/make-a-bivariate-choropleth-map/
  # upperleft = "#64ACBE", upperright = "#574249", bottomleft = "#E8E8E8", bottomright = "#C85A5A",
  # upperleft = "#BE64AC", upperright = "#3B4994", bottomleft = "#E8E8E8", bottomright = "#5AC8C8",
  # upperleft = "#73AE80", upperright = "#2A5A5B", bottomleft = "#E8E8E8", bottomright = "#6C83B5", 
  # upperleft = "#9972AF", upperright = "#804D36", bottomleft = "#E8E8E8", bottomright = "#C8B35A",
  # upperleft = "#DA8DC8", upperright = "#697AA2", bottomleft = "#E8E8E8", bottomright = "#73BCA0",
  # Similar to Teuling, Stockli, Seneviratnea (2011) [https://doi.org/10.1002/joc.2153]
  # upperleft = "#F7900A", upperright = "#993A65", bottomleft = "#44B360", bottomright = "#3A88B5",
  # Viridis style
  # upperleft = "#FEF287", upperright = "#21908D", bottomleft = "#E8F4F3", bottomright = "#9874A1",
  # Similar to Fjeldsa, Bowie, Rahbek 2012
  # upperleft = "#34C21B", upperright = "#FFFFFF", bottomleft = "#595757",  bottomright = "#A874B8",
  # Default from original source
  # upperleft = "#0096EB", upperright = "#820050", bottomleft= "#BEBEBE", bottomright = "#FFE60F",
  my.data <- seq(0, 1, .01)
  # Default uses terciles (Lucchesi and Wikle [2017] doi: 10.1002/sta4.150)
  my.class <- classInt::classIntervals(my.data,
                                       n = nbreaks,
                                       style = breakstyle,
                                       )
  my.pal.1 <- classInt::findColours(my.class, c(upperleft, bottomleft))
  my.pal.2 <- classInt::findColours(my.class, c(upperright, bottomright))
  col.matrix <- matrix(nrow = 101, ncol = 101, NA)
  for (i in 1:101) {
    my.col <- c(paste(my.pal.1[i]), paste(my.pal.2[i]))
    col.matrix[102 - i, ] <- classInt::findColours(my.class, my.col)
  }
  ## need to convert this to data.table at some stage.
  col.matrix.plot <- col.matrix %>%
    as.data.frame(.) %>% 
    mutate("Y" = row_number()) %>%
    mutate_at(.tbl = ., .vars = vars(starts_with("V")), .funs = list(as.character)) %>% 
    pivot_longer(data = ., cols = -Y, names_to = "X", values_to = "HEXCode") %>% 
    mutate("X" = as.integer(sub("V", "", .$X))) %>%
    distinct(as.factor(HEXCode), .keep_all = TRUE) %>%
    mutate(Y = rev(.$Y)) %>% 
    dplyr::select(-c(4)) %>%
    mutate("Y" = rep(seq(from = 1, to = nbreaks, by = 1), each = nbreaks),
           "X" = rep(seq(from = 1, to = nbreaks, by = 1), times = nbreaks)) %>%
    mutate("UID" = row_number())
  # Use plotLeg if you want a preview of the legend
  if (plotLeg) {
    p <- ggplot(col.matrix.plot, aes(X, Y, fill = HEXCode)) +
      geom_tile() +
      scale_fill_identity() +
      coord_equal(expand = FALSE) +
      theme_void() +
      theme(aspect.ratio = 1,
            axis.title = element_text(size = 10, colour = "black",hjust = 0.5, 
                                      vjust = 1),
            axis.title.y = element_text(size = 10, angle = 90, hjust = 0.5, vjust = 1)) +
      xlab(bquote(.(xlab) ~  symbol("\256"))) +
      ylab(bquote(.(ylab) ~  symbol("\256")))
    print(p)
    assign(
      x = "BivLegend",
      value = p,
      pos = .GlobalEnv
    )
  }
  # Use saveLeg if you want to save a copy of the legend
  if (saveLeg) {
    ggsave(filename = "bivLegend.pdf", plot = p, device = "pdf",
           path = "./", width = 4, height = 4, units = "in",
           dpi = 300)
  }
  seqs <- seq(0, 100, (100 / nbreaks))
  seqs[1] <- 1
  col.matrix <- col.matrix[c(seqs), c(seqs)]
  attr(col.matrix, "breakstyle") <- breakstyle
  attr(col.matrix, "nbreaks") <- nbreaks
  return(col.matrix)
}



# Function to assign colour-codes to raster data
# As before, by default assign tercile breaks
bivariate.map <- function(rasterx, rastery, colourmatrix = col.matrix,
                          export.colour.matrix = TRUE,
                          outname = paste0("colMatrix_rasValues", names(rasterx))) {
  # TO DO - replace raster with terra #
  #require(raster)
  require(classInt)
  # export.colour.matrix will export a data.frame of rastervalues and RGB codes 
  # to the global environment outname defines the name of the data.frame
  quanx <- values(rasterx)
  tempx <- data.frame(quanx, quantile = rep(NA, length(quanx)))
  brks <- with(tempx, classIntervals(quanx,
                                    n = attr(colourmatrix, "nbreaks"),
                                    style = attr(colourmatrix, "breakstyle"))$brks)
  ## Add (very) small amount of noise to all but the first break
  ## https://stackoverflow.com/a/19846365/1710632
  brks[-1] <- brks[-1] + seq_along(brks[-1]) * .Machine$double.eps
  r1 <- within(tempx, quantile <- cut(quanx,
                                     breaks = brks,
                                     labels = 2:length(brks),
                                     include.lowest = TRUE))
  quantr <- data.frame(r1[, 2])
  quany <- values(rastery)
  tempy <- data.frame(quany, quantile = rep(NA, length(quany)))
  brksy <- with(tempy, classIntervals(quany,
                                     n = attr(colourmatrix, "nbreaks"),
                                     style = attr(colourmatrix, "breakstyle"))$brks)
  brksy[-1] <- brksy[-1] + seq_along(brksy[-1]) * .Machine$double.eps
  r2 <- within(tempy, quantile <- cut(quany,
                                     breaks = brksy,
                                     labels = 2:length(brksy),
                                     include.lowest = TRUE
  ))
  quantr2 <- data.frame(r2[, 2])
  as.numeric.factor <- function(x) {
    as.numeric(levels(x))[x]
  }
  col.matrix2 <- colourmatrix
  cn <- unique(colourmatrix)
  for (i in 1:length(col.matrix2)) {
    ifelse(is.na(col.matrix2[i]),
           col.matrix2[i] <- 1, col.matrix2[i] <- which(
             col.matrix2[i] == cn
           )[1]
    )
  }
  # Export the colour.matrix to data.frame() in the global env
  # Can then save with write.table() and use in ArcMap/QGIS
  # Need to save the output raster as integer data-type
  if (export.colour.matrix) {
    # create a dataframe of colours corresponding to raster values
    exportCols <- as.data.frame(cbind(
      as.vector(col.matrix2), as.vector(colourmatrix),
      t(col2rgb(as.vector(colourmatrix)))
    ))
    # rename columns of data.frame()
    colnames(exportCols)[1:2] <- c("rasValue", "HEX")
    #return(exportCols)
    # Export to the global environment
    assign(
      x = outname,
      value = exportCols,
      pos = .GlobalEnv
    )
  }
  cols <- numeric(length(quantr[, 1]))
  for (i in 1:length(quantr[, 1])) {
    a <- as.numeric.factor(quantr[i, 1])
    b <- as.numeric.factor(quantr2[i, 1])
    cols[i] <- as.numeric(col.matrix2[b, a])
  }
  r <- rasterx
  r[] <- cols
  return(r)
}

```


##Put potential water storage into a raster
```{r}
#convert to spatVector object
sv_AllSierras <- terra::vect(AllSierras_DamCapacity)

#Create empty raster called "er"
er <- rast(ext(contFireRisk), resolution=res(contFireRisk)) 
crs(er) <- crs(contFireRisk)

#Use rasterize function in terra to put volume column into a raster
nr <- terra::rasterize(sv_AllSierras, er, field= "volume", fun = "sum", touches = TRUE, update = TRUE)
plot(nr)#check that it worked

volumeR <- nr

#Make sure fire risk (riskExtract) is on same raster scale as volume
fireResilience <- extend(riskExtract, contFireRisk)

writeRaster(fireResilience, "fireResilience.tif", overwrite=T)
writeRaster(volumeR, "waterStorage.tif", overwrite=T)
```


##Extract data to streams network and beaver presence
```{r}
#Extract fire layer to just high quality (hq) streams
highRisk_Streamshq <- extract(highRisk, highquality, xy = TRUE, touches = TRUE)
highRisk_Streamshq <- highRisk_Streamshq[,c(3,4,2)] #reorder for Rast function
highRisk_Streamshq <- rast(highRisk_Streamshq, type = 'xyz')
wkt <- crs(contFireRisk)
crs(highRisk_Streamshq) <- wkt
highRiskHighQualtest <- highRisk_Streamshq

#make sure it's the right size
waterStorage <- rast("waterStorage.tif")
highRiskHighQualtest <- extend(highRiskHighQualtest, waterStorage)

#save as raster
writeRaster(highRiskHighQualtest, "highRiskHighQual2.tif", overwrite=TRUE)

#read in your data 
highRiskHighQual <- rast("highRiskHighQual2.tif")
waterStorage <- rast("waterStorage.tif")
waterStorage[is.na(waterStorage)] <- 0
highRiskHighQual[is.na(highRiskHighQual)] <- 0
waterStorage <- mask(waterStorage, WatershedBoundaries)
highRiskHighQual <- mask(highRiskHighQual, WatershedBoundaries)
waterStorage[(waterStorage[]==0)] <- NA

r4 <- c(highRiskHighQual, waterStorage)
names(r4) <- c("highRiskHighQual","waterStorage")
```

##Create bivariate cloropleth map with 4 colors
```{r cache=TRUE}
# Define the number of breaks
nBreaks <- 2

# Create the colour matrix
col.matrixQ4 <- colmat(nbreaks = nBreaks, breakstyle = "quantile",
                       xlab = "Fire", ylab = "Water", 
                      bottomright = "#c94040", upperright = "#473239",
                       bottomleft = "#d4d4d4", upperleft = "#279dba",
                       saveLeg = TRUE, plotLeg = TRUE)

# create the bivariate raster
#if (!file.exists("bivmapQ.tif")) {
  bivmapQ4 <- bivariate.map(rasterx = r4[["highRiskHighQual"]], rastery = r4[["waterStorage"]],
                          export.colour.matrix = TRUE,
                          colourmatrix = col.matrixQ4, 
                          )
  writeRaster(bivmapQ4, "bivmapQ4.tif", overwrite = T)
#}
bivmapQ4 <- rast("bivmapQ4.tif")
saveRDS(bivmapQ4, 'bivmapQ4.rds')

# Convert to dataframe for plotting with ggplot
library(data.table)
bivMapDFQ4 <- setDT(as.data.frame(bivmapQ4, xy = TRUE))
colnames(bivMapDFQ4)[3] <- "BivValue"
bivMapDFQ4 <- melt(bivMapDFQ4, id.vars = c("x", "y"),
                   measure.vars = "BivValue",
                   value.name = "bivVal",
                   variable.name = "Variable")

plot(bivmapQ4)
# Make the map using ggplot


#Map
map_q5 <- ggplot() +
    geom_tile(data = bivMapDFQ4, aes(x = x, y = y, fill = bivVal)) +
      scale_fill_gradientn(colours = col.matrixQ4, na.value = "transparent") + 
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA, color = '#939393') +
    theme_classic() + theme(panel.grid.major = element_blank(),
                            panel.grid.minor = element_blank()) +
    theme(text = element_text(size = 10, colour = "black")) +
    borders(colour = "black", size = 0.1) +
    coord_sf() +
    theme(legend.position = "none",
          plot.background = element_blank(),
          strip.text = element_blank(), 
          #axis.text.y = element_blank(),
          #axis.text = element_blank(),
          axis.title = element_blank())

map_q5 <- map_q5 + inset_element(BivLegend, 0, 0, 0.3, 0.2)
```
##Post processing; assign 4 colors
```{r}
colMatrix_rasValueshighRiskHighQual %>%
  distinct(rasValue, HEX)
#1	#E8E8E8			
#2	#64ACBE	blue	
#5	#C85A5A		red
#6	#574249  purple

show_col(colMatrix_rasValueshighRiskHighQual$HEX)
#HOOK UP THE COLOR WITH THE  HEX CODE and the  raster number 

#check and see what it looks like
plot(bivmapQ4)
unique(bivmapQ4)


#hook up to watershed boundaries to aggregate by watershed
WatershedBoundaries$bivmap <- exact_extract(bivmapQ4$highRiskHighQual, WatershedBoundaries, 'frac')
WatershedBoundaries$bivmap_mode <- exact_extract(bivmapQ4$highRiskHighQual, WatershedBoundaries, 'mode')
WatershedBoundaries$cat <- ifelse(WatershedBoundaries$bivmap_mode == 1,"neither",ifelse(WatershedBoundaries$bivmap_mode == 2,"water", ifelse(WatershedBoundaries$bivmap_mode == 5,"fire","both")))

palette_biv2 <- colorRampPalette(colors = c("#473239", "#279dba", "#d4d4d4", "#c94040"))(4)

WatershedBoundariesdf4 <- st_drop_geometry(WatershedBoundaries)
WatershedBoundariesdf4$frac_1 <- WatershedBoundariesdf4$bivmap[[1]]
WatershedBoundariesdf4$frac_2 <- WatershedBoundariesdf4$bivmap[[2]]
WatershedBoundariesdf4$frac_5 <- WatershedBoundariesdf4$bivmap[[3]]
WatershedBoundariesdf4$frac_6 <- WatershedBoundariesdf4$bivmap[[4]]

WatershedBoundariesdf4 <- WatershedBoundariesdf4 %>%
  mutate(HUCID_num = as.numeric(sub("^HUC ", "", as.character(HUCID)))) %>% 
  mutate(HUCID_num = as.character(HUCID_num))

data_long4 <- tidyr::pivot_longer(WatershedBoundariesdf4, cols = c(frac_1, frac_2, frac_5, frac_6), names_to = "variable", values_to = "percentage")

data_long4_summary <- data_long4 %>%
  filter(variable == "frac_6") 
summary(data_long4_summary$percentage)
hist(data_long4_summary$percentage)
data_long4_summary <- data_long4_summary[order(data_long4_summary$percentage, decreasing = TRUE),]
```

##Figure 5b: Barplot
```{r}
#Bold the 5 watersheds that are high risk AND have high potential fire + water benefits
# Plot
map_b4 <- ggplot(data_long4, aes(x = HUCID_num, y = percentage, fill = variable)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c(
    "frac_1" = "#d4d4d4", 
    'frac_2' = "#279dba", 
    "frac_5" = "#c94040", 
    "frac_6" = "#473239" 
    )) +
  labs(title = "Proportion of streams in each category",
       x = "HUC ID",
       y = "Proportion") +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+
  theme(panel.grid = element_blank())+
  theme(axis.text.x = element_text(face = c(
    'plain', 'plain','plain','plain','plain','plain','plain','plain','bold','bold','plain','bold','plain','plain','plain','plain','plain','plain','plain','plain','plain','plain','plain','plain','plain','plain','bold','bold','plain','plain','plain')))+
  theme(legend.position = "none")

ggsave("barplot4.png", plot = map_b4, width = 4, height = 4.5, units = "in", dpi=300)


```
##Figure 5a: Bivariate Cloropleth map
```{r}
#Bold the 5 watersheds that are high risk AND have high potential fire + water benefits
bold_labels <- WatershedBoundaries %>% 
  filter(HUCID %in% c("18040012","18040013", "18020126","18020129", "18020125"))

map_q6 <- ggplot() +
    geom_tile(data = bivMapDFQ4, aes(x = x, y = y, fill = bivVal)) +
      scale_fill_gradientn(colours = col.matrixQ4, na.value = "transparent") + 
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA, color = '#939393') +
    geom_sf(data = bold_labels, fill = NA, lwd = .55) +
    theme_classic() + theme(panel.grid.major = element_blank(),
                            panel.grid.minor = element_blank()) +
    theme(text = element_text(size = 12, colour = "black")) +
    borders(colour = "black", size = 0.1) +
    coord_sf() +
    theme(legend.position = "none",
          plot.background = element_blank(),
          strip.text = element_blank(), 
          #axis.text.y = element_blank(),
          #axis.text = element_blank(),
          axis.title = element_blank())


map_q6 <- map_q6 + inset_element(BivLegend, 0, .1, 0.3, 0.2)

ggsave("map_q6.png", plot = map_q6, width = 7.6, height = 4.69, units = "in", dpi = 300)
```


##Figure 5 Layout
```{r}
library(Cairo)
png(filename = "map_q6png.png", width = 7.6, height = 4.69, units = "in", type = "cairo", res = 1200) 
map_q6
dev.off()
while (!is.null(dev.list()))  dev.off()
```



#Water deficit (NDC)
##Clean up data
```{r}
counties <- counties(c("California", "Nevada"))
#plot(counties)

counties <- st_make_valid(counties) %>%
  dplyr::mutate(valid =st_is_valid(counties)) %>% 
  dplyr::filter(valid=="TRUE") 

#project
counties <- st_transform(counties, 3310)

#sort by name
counties$County <- counties$NAME 

#pull CA and NV
counties$State <- ifelse(counties$STATEFP == "06", "California", "Nevada")

#join with ndc dataset, making the ndc dataset have a spatial element
ndc_cty <- left_join(counties, ndc, by = c("County","State"))
```

##Intersect with watersheds
```{r}
# Create a fresh area variable for watersheds
WatershedBoundaries <- mutate(WatershedBoundaries, watershed_area = st_area(WatershedBoundaries))
ndc_cty <- mutate(ndc_cty, county_area = st_area(ndc_cty))

# Re-run intersections and calculations to  calculate HUC ndc values (instead of by county)
intersect_ndc <- st_intersection(WatershedBoundaries,ndc_cty) %>% 
  mutate(intersect_area = st_area(.)) %>% 
  mutate(coverage = as.numeric(intersect_area/county_area)) %>% 
  mutate(intersect_ndc = coverage * NDC) %>%
  mutate_if(is.numeric, round, 5) %>% 
  dplyr::select(HUCID, intersect_ndc) %>%   
  st_drop_geometry() %>% 
  group_by(HUCID) %>% 
  summarize(huc_ndc = sum(intersect_ndc))


# Merge to watershed boundaries dataset
WatershedBoundaries <- left_join(WatershedBoundaries, intersect_ndc, by = "HUCID")

```

##Double check results 
```{r}
summary(WatershedBoundaries$huc_ndc)

hucndc_plot <- ggplot() +
    geom_sf(data = WatershedBoundaries, aes(fill = (huc_ndc)), lwd = 0.1) +
    scale_fill_gradient(limits = c(0, 30),
                      oob = scales::squish,
                      labels = c("0", "10", "20", "30+"))+
    theme_minimal()+
    ggtitle(expression(paste("NDC by HUC8"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    theme(panel.border = element_rect(colour = "black", fill=NA))

```

##Data wrangling
```{r}
#Notes:
#firerisk_normalized = sum of high fire risk pixels / total pixels 
#firerisk_normalized_Streamshq = sum of fire resilient pixels (which are only on streams bc beavers are on streams) / pixels along streams 
#huc_ndc = NDC per watershed (already calculated above)
#normVol = potential volume storage / total length of streams in watershed


#1: fireRisk_normalized = area of high fire risk pixels / total pixels 
WatershedBoundaries$npixels <- exact_extract(highRisk, WatershedBoundaries, 'count')
WatershedBoundaries$area_m2 <- WatershedBoundaries$npixels*270*270  
WatershedBoundaries$area_km2 <- round(WatershedBoundaries$area_m2/1e6,2)
WatershedBoundaries$total_area <- as.numeric(st_area(WatershedBoundaries))
WatershedBoundaries$total_area_km2 <- round(WatershedBoundaries$total_area/1e6,2)
WatershedBoundaries$firerisk_normalized <- WatershedBoundaries$area_m2 / WatershedBoundaries$total_area



#2: firerisk_normalized_Streamshq = area of fire resilient pixels / pixels along streams 
#High fire risk pixels along streams
highRisk_Streams <- extract(highRisk, AllSierras_DamCapacity, xy = TRUE, touches = TRUE, na.rm=T)
highRisk_Streams <- highRisk_Streams[,c(3,4,2)] #reorder for Rast function
highRisk_Streams <- highRisk_Streams[complete.cases(highRisk_Streams), ]
highRisk_Streams <- rast(highRisk_Streams, type = 'xyz')
wkt <- crs(contFireRisk)
crs(highRisk_Streams) <- wkt
#make sure it's the right size
highRisk_Streams <- extend(highRisk_Streams, contFireRisk)

#extract to watersheds
WatershedBoundaries$npixels_Streams <- exact_extract(highRisk_Streams, WatershedBoundaries, 'count')
WatershedBoundaries$area_m2_Streams <- WatershedBoundaries$npixels_Streams*270*270  
WatershedBoundaries$area_km2_Streams <- round(WatershedBoundaries$area_m2_Streams/1e6,2)

#High fire risk pixels along high quality streams (doing this to be able to normalize)
highRisk_Streamshq <- extract(highRisk, highquality, xy = TRUE, touches = TRUE)
highRisk_Streamshq <- highRisk_Streamshq[,c(3,4,2)] #reorder for Rast function
highRisk_Streamshq <- highRisk_Streamshq[complete.cases(highRisk_Streamshq), ]
highRisk_Streamshq <- rast(highRisk_Streamshq, type = 'xyz')
wkt <- crs(contFireRisk)
crs(highRisk_Streamshq) <- wkt
plot(highRisk_Streamshq)
#make sure it's the right size
highRisk_Streamshq <- extend(highRisk_Streamshq, contFireRisk)

#extract to watersheds
WatershedBoundaries$npixels_Streamshq <- exact_extract(highRisk_Streamshq, WatershedBoundaries, 'count')
WatershedBoundaries$area_m2_Streamshq <- WatershedBoundaries$npixels_Streams*270*270  
WatershedBoundaries$area_km2_Streamshq <- round(WatershedBoundaries$area_m2_Streams/1e6,2)
WatershedBoundaries$firerisk_normalized_Streamshq <- WatershedBoundaries$area_m2_Streamshq / WatershedBoundaries$total_area


#3: Normalized volume / stream km
AllSierras_DamCapacity$VolumePerKm <-  AllSierras_DamCapacity$volume/((AllSierras_DamCapacity$iGeo_Len)*0.001) #convert iGeo_Len to km
watersheds <- st_join(WatershedBoundaries,AllSierras_DamCapacity)

#making a non-geometric, HUC-sorted data frame so we can summarize normvol and other variables by watershed more easily
watersheds <- st_drop_geometry(watersheds)
```

##Appendix 1: Table S2
```{r}
watershedstest <- watersheds %>%
    group_by(HUCID) %>% 
    summarise(normVol = mean(VolumePerKm), 
              meanDamCap = mean(oCC_EX),
              meanHistDamCap = mean(oCC_HPE),
              meanHistRemain = mean(mCC_EXvHPE, na.rm=T),
              damCapCount = sum(mCC_EX_CT),
              totalVol = sum(volume)) 

WatershedBoundaries <- merge(WatershedBoundaries, watershedstest, by = "HUCID")
watershed_csv <- st_drop_geometry(WatershedBoundaries)
write.csv(watershed_csv, "watershed_csv.csv", row.names = TRUE)

summary(WatershedBoundaries$normVol)
```


##Figure 3
```{r}
firerisk_normalized_Streamshq_plot <- ggplot() +
    geom_sf(data = WatershedBoundaries, aes(fill = (firerisk_normalized_Streamshq)), lwd = 0.1) +
    scale_fill_gradient(low = "#e8e8e8", high ="#c85a5a", name = "% of High \nRisk Areas",labels = scales::percent, breaks=c(min(watersheds$firerisk_normalized_Streamshq),max(watersheds$firerisk_normalized_Streamshq)))+
    theme_minimal()+
    ggtitle(expression(paste("Potential Fire Resilience"))) +
    theme(plot.title = element_text(hjust = 0, size = 12),
          plot.subtitle = element_text(hjust = 0)) +
  theme(legend.text = element_text(size=7),
          legend.title = element_text(size = 7),
          legend.position = c(.2,.20),
          legend.key.size = unit(.8, "lines"),
          legend.title.align= 0.5)+
      theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.grid.major = element_line(colour = "transparent")) +
    theme(axis.text.x = element_blank(), axis.text.y = element_blank()) 


firerisk_plot <- ggplot() +
    geom_sf(data = WatershedBoundaries, aes(fill = (firerisk_normalized)), lwd = 0.1) +
    scale_fill_gradient(low = "#e8e8e8", high ="#FFA500", name = "% Area\nWHP>2000",labels = scales::percent, breaks=c(min(watersheds$firerisk_normalized),max(watersheds$firerisk_normalized)))+
    theme_minimal()+
    ggtitle(expression(paste("Fire Risk"))) +
    theme(plot.title = element_text(hjust = 0, size = 12),
          plot.subtitle = element_text(hjust = 0)) +
   theme(legend.text = element_text(size=7),
          legend.title = element_text(size = 7),
          legend.position = c(.2,.20),
          legend.key.size = unit(.8, "lines"),
          legend.title.align= 0.5)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.grid.major = element_line(colour = "transparent")) +
    theme(axis.text.x = element_blank(), axis.text.y = element_blank()) 


normVol_plot <- ggplot() +
  geom_sf(data = WatershedBoundaries) +
  geom_sf(data = WatershedBoundaries, aes(fill = normVol), inherit.aes = FALSE) +
  scale_fill_gradient(low = "#e8e8e8", high = "#64abce", name = "Potential Water \nStorage (m3/km)",breaks=c(round(min(WatershedBoundaries$normVol)),round(max(WatershedBoundaries$normVol))))+
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("Potential Water Storage"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0, size = 12),
          plot.subtitle = element_text(hjust = 0)) + 
  theme(legend.text = element_text(size=7),
          legend.title = element_text(size = 7),
          legend.position = c(.2,.20),
          legend.key.size = unit(.8, "lines"),
          legend.title.align= 0.5)+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.grid.major = element_line(colour = "transparent")) +
    theme(axis.text.x = element_blank(), axis.text.y = element_blank()) 


ndcblue_plot <- ggplot() +
  geom_sf(data = WatershedBoundaries) +
  geom_sf(data = WatershedBoundaries, aes(fill = huc_ndc), inherit.aes = FALSE) +
  scale_fill_gradient(low = "#e8e8e8", high = "#73ae80", name = "NDC", 
                      limits = c(0, 30),
                      oob = scales::squish,
                      labels = c("0", "10", "20", "30+"))+
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("Water Deficit (NDC)"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0, size = 12),
          plot.subtitle = element_text(hjust = 0)) + 
  theme(legend.text = element_text(size=7),
          legend.title = element_text(size = 7),
          legend.position = c(.2,.20),
          legend.key.size = unit(.8, "lines"),
          legend.title.align= 0.5,
           panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),  # Remove default panel border
          axis.line.x = element_line(color = "black"),  # Add border to x axis
          axis.line.y = element_line(color = "black")) +   # Add border to y axis
  labs(color = "dams/km", size = 10)

```

##Figure 3 Layout
```{r}
p <-  (ndcblue_plot + normVol_plot) / (firerisk_plot + firerisk_normalized_Streamshq_plot)

p_abs <- p + plot_annotation(tag_levels = 'A')

ggsave("Fig_4maps.png", plot = p_abs, width = 5.15, height = 8, units = "in", bg = "white", dpi=900)
```


##Figure 4a
```{r}
summary(WatershedBoundaries$firerisk_normalized)
#mean = 0.2
x_value <- 0.2
y_value = 1



#Vertical black line represents % high fire risk = 0.2, which is the mean
#horizontal black line represents NDC <1, indicating watersheds with no water deficit
st <- ggplot()+
  geom_point(data = WatershedBoundaries, aes(x = firerisk_normalized, y = (huc_ndc), size = normVol, color = firerisk_normalized_Streamshq))+ 
  geom_vline(xintercept = x_value, color = "black", linetype = "solid") +
  geom_hline(yintercept = y_value, color = "black", linetype = "solid") +
  theme_minimal()+
  scale_color_gradient(low = "#e8e8e8", high ="#c85a5a", name = "Potential % Stream Area \nw/ Fire Resilience", labels = scales::percent,breaks=c(min(WatershedBoundaries$firerisk_normalized_Streamshq),max(WatershedBoundaries$firerisk_normalized_Streamshq)))+
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE), trans = "log10")+
  ggtitle(expression(paste("Water Deficit vs. Fire Risk"))) +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
  labs(x = "Porportion of Watershed Area with High Fire Risk",
       y = "Watershed-scale Water Deficit (NDC)", 
       size = "Potential Water \nStorage")+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
  theme(panel.border = element_rect(colour = "black", fill=NA))  
```
##Figure 4b and 4c
```{r}
selection <- WatershedBoundaries %>% 
  filter(HUCID %in% c("16050201","18040012","18040010", "18040013", "18020126","18020129", "18020125", "18040008", "18030001", "16050102"))

ndc_selection <- ggplot() +
   # geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = WatershedBoundaries, fill = NA, lwd = 0.1) +
    geom_sf(data = selection, aes(fill = normVol), lwd = .6) +
    scale_fill_gradient(low = "#e8e8e8", high = "#64abce", name = "Potential Water Storage \n(m3/km)", breaks=c(round(min(selection$normVol)),round(max(selection$normVol))))+
    theme_minimal()+
    #ggtitle(expression(paste("Potential Water Storage"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5),
          legend.key.size = unit(1, "lines")) +
    theme(legend.text = element_text(size=8),
          legend.title = element_text(size = 8),
          legend.position = c(-.1,.20),
          legend.title.align= 0.5)+
    #labs(color = "dams/km", size=10)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.grid.major = element_line(colour = "transparent")) +
    theme(axis.text.x = element_blank(), axis.text.y = element_blank()) 
   # theme(panel.border = element_rect(colour = "black", fill=NA))


fire_selection <- ggplot() +
   # geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = WatershedBoundaries, fill = NA, lwd = 0.1) +
    geom_sf(data = selection, aes(fill = firerisk_normalized_Streamshq), lwd = .6) +
    scale_fill_gradient(low = "#e8e8e8", high ="#c85a5a", name = "Potential Fire Resilience \n(% of high risk areas)", labels = scales::percent, breaks=c(min(selection$firerisk_normalized_Streamshq),max(selection$firerisk_normalized_Streamshq)))+
    theme_minimal()+
    #ggtitle(expression(paste("Potential Fire Resilience"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5),
          legend.key.size = unit(1, "lines")) +
    theme(legend.text = element_text(size=8),
          legend.title = element_text(size = 8),
          legend.position = c(-.1,.20),
          legend.title.align= 0.5)+
    #labs(color = "dams/km", size=10)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.grid.major = element_line(colour = "transparent")) +
    theme(axis.text.x = element_blank(), axis.text.y = element_blank()) 
   # theme(panel.border = element_rect(colour = "black", fill=NA))

(ndc_selection + fire_selection)

```
##Figure 4 Layout
```{r}
#Assembled in photoshop
layout <- "
AA
AA
B#
"
scatter <- st + ndc_selection + fire_selection + 
  plot_layout(design = layout) +    plot_annotation(tag_levels = 'A')
  
ggsave("Fig_scatter.png", plot = scatter, width = 6.34, height = 8, units = "in", bg = "white", dpi=900)


layout <- "
##
##
#C
"
scatter <-  fire_selection + 
  plot_layout(design = layout) +    plot_annotation(tag_levels = list(LETTERS[3]))
  
ggsave("Fig_scatterC.png", plot = scatter, width = 6.34, height = 8, units = "in", bg = "white", dpi=900)
```

#LandOwnership
##Select private land
```{r}
#Accordig to SMA metadata, "Undetermined" Category refers to non-federal land. There are separate designations for private and state land specifically that do not show up in this dataset, so we will assume all undetermined land is private land (https://www.arcgis.com/sharing/rest/content/items/6bf2e737c59d4111be92420ee5ab0b46/info/metadata/metadata.xml?format=default&output=html)

private <- landownership[landownership$ADMIN_UNIT=="Undetermined",]
private <- private[!is.na(private$OBJECTID), ]

#Check on map
privatemap <- ggplot() +
  geom_sf(data = private, aes(fill = ADMIN_UNIT)) +
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("Private Land"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5))+
  theme(panel.border = element_rect(colour = "black", fill=NA))

```

##Add private/other column
```{r}
landownership$desig <- ifelse(is.na(landownership$ADMIN_UNIT), "other",
                              ifelse(landownership$ADMIN_UNIT == "Undetermined", "private", "other"))

```

##Appendix 1: Table S4
```{r}
#Fire
##Fire resilience on private land
private_fire <- crop(highRisk_Streamshq,private)
private_fire <- mask(private_fire,private) #fire resilience on private land

##Total area of fire resilience on private land
total_private_fire_npixels <- exact_extract(private_fire, private, 'count') #high resil fire pixels in private land
total_private_fire_npixels <- sum(total_private_fire_npixels)
total_private_fire_area <- total_private_fire_npixels*270*270  
total_private_fire_areakm2 <- round(total_private_fire_area/1e6,2)

##Watershed area of fire resilience on private land
WatershedBoundaries$private_fire_watershed_npixels <- exact_extract(private_fire, WatershedBoundaries, 'count') #high resil fire pixels in private land by watershed
WatershedBoundaries$total_private_fire_watershed_area <- WatershedBoundaries$private_fire_watershed_npixels*270*270  
WatershedBoundaries$total_private_fire_watershed_areakm2 <- round(WatershedBoundaries$total_private_fire_watershed_area/1e6,2)
```

##Appendix 1: Table S4 cont. 
###Takes a very long time to run
###To bypass use the saved "private_dams" and "private_dams_watersheds" .rds files
```{r}
#Bypass slow run times by using .rds files that are the result of the following chunk: 
private_dams <- readRDS("private_dams.rds")
private_dams_watersheds <- readRDS("private_dams_watersheds.rds")


#Water/Dam capacity on private land
private_dams <- st_intersection(private, AllSierras_DamCapacity)#this is very slow, expect 2 hours
private_dams_watersheds <- st_intersection(WatershedBoundaries, private_dams)
private_dams_watersheds_df <- st_drop_geometry(private_dams_watersheds)
  
##Watershed water storate and dam capacity on private land 
lo_dams <- private_dams_watersheds_df %>% 
  group_by(HUCID) %>%
  summarize(private_water = sum(volume),
            private_damCt = sum(mCC_EX_CT)) 


#Save as .rds files to avoid running for 2 hrs
saveRDS(private_dams,"private_dams.rds")
saveRDS(private_dams_watersheds,"private_dams_watersheds.rds")
```

##Appendix 1: Table S4 cont. 2
```{r}
#total area
private_watersheds <- st_intersection(WatershedBoundaries,private)
private_watersheds$total_area_private <- as.numeric(st_area(private_watersheds))

#Area of private land by watershed
privateArea <- private_watersheds %>% 
  group_by(HUCID) %>% 
  summarize(total_area_private = sum(total_area_private))

#put it all together
privateArea <- st_drop_geometry(privateArea)
merged_df <- merge(privateArea, lo_dams, by = "HUCID", all = TRUE)
merged_df <- st_drop_geometry(merged_df)
watershedboundaries_csv <- st_drop_geometry(WatershedBoundaries)
merged_df <- merge(merged_df, watershedboundaries_csv, by = "HUCID", all = TRUE)

#Numbers for Table S4
TableS4 <- merged_df %>% 
  reframe(HUC = HUCID,
          pct_private = total_area_private/total_area,
          pct_dams = private_damCt/damCapCount, 
          pct_water = private_water/totalVol,
          pct_fire = total_private_fire_watershed_areakm2/area_km2_Streamshq)


write.csv(TableS4, "TableS4.csv", row.names = TRUE)

```