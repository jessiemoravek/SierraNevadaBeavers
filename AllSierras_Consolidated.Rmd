---
title: "AllSierras_Consolidated"
output: html_document
---

```{r include=FALSE}
library(tidyverse)
library(ggplot2)
library(dplyr)
library(dataRetrieval)
library(sf)
library(maps)
library(sp)
library(ncdf4)
library(sf)
library(sp)
library(lwgeom)
library(terra)
library(raster)
library(mapview)
library(tidyterra)
library(viridis)
library(MetBrewer)
library(stars)
library(data.table)
library(tigris)
library(patchwork)
library(car)
library(multcomp)
library(exactextractr)
library(scales)
library(ggrepel)
```

#Input Files (all together)
```{r}
AllSierras_DamCapacity <- readRDS("AllSierras_DamCapacity_volume.rds")
background <- readRDS("background.rds")
#PADUS <- readRDS("PADUS.rds")
WatershedBoundaries <- readRDS("WatershedBoundaries.rds")
#PADUS_clip <- readRDS("PADUS_clip.rds")
#PADUS_Gap12 <- readRDS("PADUS_Gap12.rds")
#DamCap_GAP12 <- readRDS("DamCap_GAP12.rds")
#TNC_DamCapacity <- readRDS("TNC_DamCapacity.rds")
contFireRisk <- readRDS("contFireRisk.rds")
#contFireRisk <- readRDS("contFireRisk.rds")
#watershedsPoly <- readRDS("watershedsPoly.rds")
#watersheds <- readRDS("watersheds.rds")
#intermittent <- readRDS("intermittent.rds")
landownership <- readRDS("landownership.rds")
private_dams_watersheds <- readRDS("private_dams_watersheds.rds")
private_dams <- readRDS("private_dams.rds")


```

###Dam Capacity
```{r}
# Read in the shapefile with st_read()
AllSierras_DamCapacity <- st_read("C:/Users/jessie_moravek/Desktop/SierraNevadaBeavers/AllSierras_DamCapacity6.shp")

#remove unneeded shapefiles
file.remove(list.files(pattern = "AllSierras_DamCapacity*",recursive = F))

#Project to wkt (NASA projection)
AllSierras_DamCapacity <- st_transform(AllSierras_DamCapacity, 3310)

saveRDS(AllSierras_DamCapacity,"AllSierras_DamCapacity.rds")

```

###Volume calculation
```{r}
for (i in AllSierras_DamCapacity){ #for each stream segment in the BRAT model output shapefile
  damCt <- AllSierras_DamCapacity$mCC_EX_CT #number of beaver dams per segment (calculated based on dam density and segment length as the column mCC_EX_CT in the attribute table)
  slope <- AllSierras_DamCapacity$iGeo_Slope #meters
  da <- AllSierras_DamCapacity$iGeo_DA #m2
  width <- ifelse(da < 4.95,2.18*(da)^0.191,
                  ifelse(da >= 4.95 & da < 377,1.41*(da)^0.462,7.18*(da)^0.183)) #based on Scamardo et al. 2022
  height <- 1 #assume all beaver dams are 1m tall
  length <- height/slope #trigonometry: slope = rise/run, so run = rise/slope
  maxLength<- (AllSierras_DamCapacity$iGeo_Len/damCt) #set a maximum length so that we can change volume calculations if there are so many dams that they all run together
  volume <- ifelse(length < maxLength, 0.5*(height)*(width)*(length)*(damCt),(height)*(width)*(maxLength)*(damCt))
  surfaceArea <- ifelse(length < maxLength, (width)*(length)*(damCt),(width)*(maxLength)*(damCt))
  AllSierras_DamCapacity$width <- width
  AllSierras_DamCapacity$volume <- volume #m3
  AllSierras_DamCapacity$surfaceArea <- surfaceArea #m2
} 


saveRDS(AllSierras_DamCapacity,"AllSierras_DamCapacity_volume.rds")
```

#Calculate Historical Percent Remaining
```{r}
AllSierras_DamCapacity$mCC_EXvHPE <- AllSierras_DamCapacity$oCC_EX/AllSierras_DamCapacity$oCC_HPE
#When doing this division, sometimes we get 0/0 = Inf, especially in areas that are slope limited. In one way of looking at it, these values should be converted to 1, since dam capacity stayed the same from historic to current. However we converted them to NA? 
AllSierras_DamCapacity$mCC_EXvHPE[!is.finite(AllSierras_DamCapacity$mCC_EXvHPE)] <- NA
```

#Change in veg suitability
```{r}
AllSierras_DamCapacity$VegChange100 <-  AllSierras_DamCapacity$iVeg100EX - AllSierras_DamCapacity$iVeg100Hpe 

```

##Historical volume calculation
```{r}
for (i in AllSierras_DamCapacity){ #for each stream segment in the BRAT model output shapefile
  damCt <- AllSierras_DamCapacity$mCC_HPE_CT #number of beaver dams per segment (calculated based on dam density and segment length as the column mCC_HPE_CT in the attribute table)
  slope <- AllSierras_DamCapacity$iGeo_Slope #meters
  da <- AllSierras_DamCapacity$iGeo_DA #m2
  width <- ifelse(da < 4.95,2.18*(da)^0.191,
                  ifelse(da >= 4.95 & da < 377,1.41*(da)^0.462,7.18*(da)^0.183)) #based on Scamardo et al. 2022
  height <- 1 #assume all beaver dams are 1m tall
  length <- height/slope #trigonometry: slope = rise/run, so run = rise/slope
  maxLength<- (AllSierras_DamCapacity$iGeo_Len/damCt) #set a maximum length so that we can change volume calculations if there are so many dams that they all run together
  volumeHist <- ifelse(length < maxLength, 0.5*(height)*(width)*(length)*(damCt),(height)*(width)*(maxLength)*(damCt))
  surfaceAreaHist <- ifelse(length < maxLength, (width)*(length)*(damCt),(width)*(maxLength)*(damCt))
  AllSierras_DamCapacity$width <- width
  AllSierras_DamCapacity$volumeHist <- volumeHist #m3
  AllSierras_DamCapacity$surfaceAreaHist <- surfaceAreaHist #m2
} 

```

##Volume Change
```{r}
AllSierras_DamCapacity$VolumeChange <-  AllSierras_DamCapacity$volume - AllSierras_DamCapacity$volumeHist

```

##LandOwnership
```{r}
# Read in the shapefile with st_read()
landownership <- st_read("C:/Users/jessie_moravek/Desktop/SierraNevadaBeavers/LandOwnership.shp")

#remove unneeded shapefiles
file.remove(list.files(pattern = "LandOwnership*",recursive = F))

#Project to wkt (NASA projection)
landownership <- st_transform(landownership, 3310)
crs(AllSierras_DamCapacity) ==crs(landownership)


saveRDS(landownership,"landownership.rds")
```


#Summary Stats
```{r}
sum(AllSierras_DamCapacity$volume)
summary(AllSierras_DamCapacity$volume)
hist(AllSierras_DamCapacity$volume)
sum(WatershedBoundaries$area_km2_Streamshq)
summary(WatershedBoundaries$area_km2_Streamshq)
sum(AllSierras_DamCapacity$mCC_EX_CT)
sum(AllSierras_DamCapacity$mCC_HPE_CT)
```

##Watershed Boundaries Map

```{r}
palette_new <- colorRampPalette(colors = c("#ff0000", "#ffa500", "#ffff00", "#00FF50", "#4900FF"))(5)

w <- ggplot() +
    geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = WatershedBoundaries, fill = "#b0b0b0", lwd = 0.1, alpha = 0.5 ) +
    scale_color_manual(values=palette_new)+
   # geom_sf_text(data = WatershedBoundaries, aes(label = HUCID)) + 
   #geom_sf_label_repel(data = WatershedBoundaries, aes(label = HUCID),  
                      #size = 3,  # Adjust text size
                      #color = "black",  # Text color
                      #label.padding = unit(0.2, "lines"),  #
                      #label.size = 0.2,  # Border size of the label box
                      #fontface = "bold",  # Font face
                      #max.overlaps = Inf) +  # 
    ggtitle(expression(paste("Watershed Boundaries"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    #theme(element_text(size=10),legend.position = c(.15,.2))+
    #labs(color = "dams/km", size=10)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.border = element_rect(colour = "black", fill=NA))

ggsave("Fig_watershedboundaries.png", plot = w, width = 6.8, height = 8, units = "in", bg = "white", dpi=300)

```


##Current Dam Capacity Map
```{r}
#scales::show_col(palette_new)

c <- ggplot() +
    #geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = transform(AllSierras_DamCapacity, DamCapacity=cut(oCC_EX, breaks = c(0,.1,2,5,15,40), include.lowest=T)),aes(color = DamCapacity)) +
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
    scale_color_manual(values=palette_new,
                        labels = c("0", "1-2", "2-5", "5-15", "15-40"))+
    theme_minimal()+
    ggtitle(expression(paste("Current Dam Capacity"))) +
    theme(plot.title = element_text(hjust = 1, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    theme(legend.text = element_text(size=8),
          legend.title = element_text(size = 8),
          legend.position = c(.2,.20))+
    #theme(element_text(size=10),legend.position = c(.15,.2))+
     labs(color = "dams/km", size=10)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.grid.major = element_line(colour = "transparent")) +
    theme(axis.text.x = element_blank(), axis.text.y = element_blank()) 
   # theme(panel.border = element_rect(colour = "black", fill=NA))

```

##Historical Dam Capacity Map
```{r}

h <- ggplot() +
  # geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1) +
  geom_sf(data = transform(AllSierras_DamCapacity, DamCapacity = cut(oCC_HPE, breaks = c(0, .1, 2, 5, 15, 40), include.lowest = TRUE)), aes(color = DamCapacity)) +
  geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
  scale_color_manual(values = palette_new, labels = c("0", "1-2", "2-5", "5-15", "15-40")) +
  theme_minimal() +
  ggtitle(expression(paste("Historical Dam Capacity"))) +
  theme(
    plot.title = element_text(hjust = 1, size = 12),
    plot.subtitle = element_text(hjust = 0.5),
    legend.text = element_text(size = 8),
    legend.title = element_text(size = 8),
    legend.position = c(0.2, 0.20),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),  # Remove default panel border
    axis.line.x = element_line(color = "black"),  # Add border to x axis
    axis.line.y = element_line(color = "black")   # Add border to y axis
  ) +
  labs(color = "dams/km", size = 10)

```



##Percent Remaining Map
```{r}
r <- ggplot() +
    #geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = transform(AllSierras_DamCapacity, DamCapacity=cut(mCC_EXvHPE, breaks = c(0,.25,.5,.75,1,70), include.lowest=T)),aes(color = DamCapacity)) +
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
    scale_color_manual(values=palette_new,
                        labels = c("0", "1-2", "2-5", "5-15", "15-40"))+
    theme_minimal()+
    ggtitle(expression(paste("% Capacity Remaining"))) +
    theme(plot.title = element_text(hjust = 1, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    theme(legend.text = element_text(size=8),
          legend.title = element_text(size = 8),
          legend.position = c(.2,.20))+
    #theme(element_text(size=10),legend.position = c(.15,.2))+
    labs(color = "dams/km", size=10)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.grid.major = element_line(colour = "transparent")) +
    theme(axis.text.x = element_blank(), axis.text.y = element_blank()) 
    #theme(panel.border = element_rect(colour = "black", fill=NA))

```



##Change in veg suitability map
```{r}

veg <- ggplot() +
    geom_sf(data = AllSierras_DamCapacity, aes(color = VegChange100)) +
    scale_color_gradient2(low = "red", mid = "white", high = "blue", midpoint = 0, na.value = "grey70")+
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
    xlab(NULL)+
    ylab(NULL)+
    ggtitle(expression(paste("Vegetation Change"))) + 
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 12),
      plot.subtitle = element_text(hjust = 0.5),
      legend.text = element_text(size = 8),
      legend.title = element_text(size = 8),
      legend.position = c(0.2, 0.20),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.border = element_blank(),  # Remove default panel border
      axis.line.x = element_line(color = "black"),  # Add border to x axis
      axis.line.y = element_line(color = "black")   # Add border to y axis
  ) +
  labs(color = "dams/km", size = 10)

ggsave("Fig_vegchange.png", plot = veg, width = 7, height = 4.32, units = "in", bg = "white", dpi=900)

```



#Change in volume
##Historical volume map
```{r}
hmap <- ggplot() +
    geom_sf(data = AllSierras_DamCapacity, aes(color = volumeHist)) +
    scale_color_viridis(discrete = FALSE, option = "plasma", na.value = "grey70")+
    xlab(NULL)+
    ylab(NULL)+
    ggtitle(expression(paste("Potential Water Storage (m3)"))) + 
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5)) +
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.border = element_rect(colour = "black", fill=NA))
```

##Current volume map
```{r}
currentVol <- ggplot() +
    geom_sf(data = AllSierras_DamCapacity, aes(color = volume)) +
    scale_color_viridis(discrete = FALSE, option = "plasma", na.value = "grey70")+
    xlab(NULL)+
    ylab(NULL)+
    ggtitle(expression(paste("Potential Water Storage (m3)"))) + 
    theme_minimal() +
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) 
```

##Volume change map
```{r}
vol <- ggplot() +
    geom_sf(data = AllSierras_DamCapacity, aes(color = VolumeChange)) +
    scale_color_gradient2(low = "red", mid = "grey70", high = "blue", midpoint = 0, na.value = "grey70")+
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
    xlab(NULL)+
    ylab(NULL)+
    ggtitle(expression(paste("Change in Volume (m3)"))) + 
    theme_minimal() +
    theme(plot.title = element_text(hjust = 1, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    theme(legend.text = element_text(size=8),
          legend.title = element_text(size = 8),
          legend.position = c(.2,.20))+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    labs(color = "Volume\nChange (m3)")+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.border = element_rect(colour = "black", fill=NA))
```

###Figure 2 Map
```{r}
fig2 <- h+c+r
fig2_abc <- fig2 + plot_annotation(tag_levels = 'A')

ggsave("Fig_damcaphist.png", plot = fig2_abc, width = 7, height = 4.32, units = "in", bg = "white", dpi=900)
```


##Normalizing volume
```{r}
AllSierras_DamCapacity$VolumePerKm <-  AllSierras_DamCapacity$volume/((AllSierras_DamCapacity$iGeo_Len)*0.001)

```
##Current volumePerKm map
```{r}
volperkm <- ggplot() +
    geom_sf(data = AllSierras_DamCapacity, aes(color = VolumePerKm)) +
    scale_color_viridis(discrete = FALSE, option = "plasma", na.value = "grey70")+
    xlab(NULL)+
    ylab(NULL)+
    ggtitle(expression(paste("Potential Water Storage (m3/km)"))) + 
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5))+
    theme(panel.border = element_rect(colour = "black", fill=NA)) 
```



#Fire Risk Continuous
```{r}
#Read in the raster 
contFireRisk <- rast("C:/Users/jessie_moravek/Desktop/SierraNevadaBeavers/FireRisk/FireRisk_4.tif")
#plot(contFireRisk)
contFireRisk <- project(contFireRisk, crs(AllSierras_DamCapacity))
crs(contFireRisk) == crs(AllSierras_DamCapacity) #== crs(WatershedBoundaries)
wkt <- crs(contFireRisk)

#Crop
contFireRisk <- crop(contFireRisk, WatershedBoundaries)
contFireRisk <- mask(contFireRisk, WatershedBoundaries)
#plot(contFireRisk)

#save
saveRDS(contFireRisk,"contFireRisk.rds")
contFireRisk <- readRDS("contFireRisk.rds")
```


##Fire risk vs. dam capacity
```{r}
contFireRisk$Band_1
contFireRisk_df <- as_data_frame(contFireRisk, xy=T)
summary(contFireRisk_df$Band_1)

summary(AllSierras_DamCapacity$oCC_EX)

fireDamExtract <- extract(contFireRisk, AllSierras_DamCapacity, xy = TRUE, touches = TRUE)
#AllSierras_DamCapacity$fireRisk <- extract(contFireRisk, AllSierras_DamCapacity, xy = TRUE, touches = TRUE)


```


##Fire risk intersection with high quality dam areas
###pull high quality areas
```{r}
highquality <- subset(AllSierras_DamCapacity, oCC_EX >= 5) #pull out good habitat
```


###Pull high fire risk pixels
```{r}
#Note: Cannot figure out how WHP classifies high and very high fire risk categories based on WHP values. Not included in metadata. For now, choosing top quartile. 
summary(contFireRisk$Band_1)
#Top quartile starts at 1095, so let's start at WHP = 2000 as high and very high risk areas (again, FOR NOW) this is conservative
#JK it might work better for plotting purposes if we use the median, which is about 350 so let's call it 400

highRisk <- contFireRisk
highRisk[highRisk[] < 2000] = NA 
plot(highRisk, zlim = c(0,70), main = "Filtered raster")

```

###Extract high risk and high quality overlap
```{r}
riskExtract <- extract(highRisk, highquality, xy = TRUE, touches = TRUE)
riskExtract <- riskExtract[,c(3,4,2)] #reorder for Rast function
riskExtract <- rast(riskExtract, type = 'xyz')
wkt <- crs(contFireRisk)
crs(riskExtract) <- wkt

hq <- ggplot() +
  geom_spatraster(data = riskExtract, aes(fill = Band_1)) +
  scale_fill_viridis_c(option = "inferno",na.value = "transparent") +
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("High Fire Risk and High Dam Capacity"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5))+
  theme(panel.border = element_rect(colour = "black", fill=NA))

summary(riskExtract)

result <- as.data.frame(riskExtract) %>%
  summarise(pixels = n()) %>% 
  mutate(`area m^2` = pixels * 270 * 270, #multiply by pixel area
         `area km^2` = round(`area m^2`/1e6,2)) 
#1365 km2 of fire resilience conferred 
```

#Intermittent
##Assign Perennial
```{r}
AllSierras_DamCapacity$Flow <- ifelse(is.na(AllSierras_DamCapacity$Flow), "perennial", AllSierras_DamCapacity$Flow)

```

##percentages
```{r}
#% of total stream km
intermittent <- AllSierras_DamCapacity %>% 
  filter(Flow == "intermittent") 
intermittent_length <- sum(intermittent$iGeo_Len) #m
total_length <- sum(AllSierras_DamCapacity$iGeo_Len)
pct_total_intermittent <- intermittent_length/total_length

#% of 0 dams/km
zero <- AllSierras_DamCapacity %>% 
  filter(oCC_EX == 0) 
pct_zero_intermittent = (sum(zero$Flow == "intermittent"))/(nrow(zero))

zero_intermittent_len <- intermittent %>% 
  filter(oCC_EX == 0) 
zero_intermittent_len <- sum(zero_intermittent_len$iGeo_Len) #m
pct_zero_intermittent_len <- zero_intermittent_len/total_length


#% of 1-2 dams/km
one_two <- AllSierras_DamCapacity %>% 
  filter(oCC_EX >= 1 & oCC_EX <= 2) 
pct_one_two_intermittent = (sum(one_two$Flow == "intermittent"))/(nrow(one_two))

one_two_intermittent_len <- intermittent %>% 
  filter(oCC_EX >= 1 & oCC_EX <= 2) 
one_two_intermittent_len <- sum(one_two_intermittent_len$iGeo_Len) #m
pct_one_two_intermittent_len <- one_two_intermittent_len/total_length


#% of 2-5 dams/km
two_five <- AllSierras_DamCapacity %>% 
  filter(oCC_EX > 2 & oCC_EX <= 5) 
pct_two_five_intermittent = (sum(two_five$Flow == "intermittent"))/(nrow(two_five))

two_five_intermittent_len <- intermittent %>% 
  filter(oCC_EX > 2 & oCC_EX <= 5) 
two_five_intermittent_len <- sum(two_five_intermittent_len$iGeo_Len) #m
pct_two_five_intermittent_len <- two_five_intermittent_len/total_length


#% of 5-15 dams/km
five_fifteen <- AllSierras_DamCapacity %>% 
  filter(oCC_EX > 5 & oCC_EX <= 15) 
pct_five_fifteen_intermittent = (sum(five_fifteen$Flow == "intermittent"))/(nrow(five_fifteen))

five_fifteen_intermittent_len <- intermittent %>% 
  filter(oCC_EX > 5 & oCC_EX <= 15) 
five_fifteen_intermittent_len <- sum(five_fifteen_intermittent_len$iGeo_Len) #m
pct_five_fifteen_intermittent_len <- five_fifteen_intermittent_len/total_length


#% of 15-40 dams/km
fifteen_forty <- AllSierras_DamCapacity %>% 
  filter(oCC_EX > 15 & oCC_EX <= 40) 
pct_fifteen_forty_intermittent = (sum(fifteen_forty$Flow == "intermittent"))/(nrow(fifteen_forty))

fifteen_forty_intermittent_len <- intermittent %>% 
  filter(oCC_EX > 15 & oCC_EX <= 40) 
fifteen_forty_intermittent_len <- sum(fifteen_forty_intermittent_len$iGeo_Len) #m
pct_fifteen_forty_intermittent_len <- fifteen_forty_intermittent_len/total_length

```

##Current Intermittent Dam Capacity Map
```{r}
#scales::show_col(palette_new)

ci <- ggplot() +
    #geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = transform(intermittent, DamCapacity=cut(oCC_EX, breaks = c(0,.1,2,5,15,40), include.lowest=T)),aes(color = DamCapacity)) +
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
    scale_color_manual(values=palette_new,
                        labels = c("0", "1-2", "2-5", "5-15", "15-40"))+
    theme_minimal()+
    ggtitle(expression(paste("Intermittent Stream Dam Capacity"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    theme(legend.text = element_text(size=8),
          legend.title = element_text(size = 8),
          legend.position = c(.2,.20))+
    #theme(element_text(size=10),legend.position = c(.15,.2))+
    labs(color = "dams/km", size=10)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.border = element_rect(colour = "black", fill=NA))

```
##percent intermittent water storage
```{r}
intermittent_water <- sum(intermittent$volume) #m
total_water <- sum(AllSierras_DamCapacity$volume)
pct_water_intermittent <- intermittent_water/total_water 

```

##percent intermittent fire resilience
```{r}
##pull high quality areas
highquality_int <- subset(intermittent, oCC_EX >= 5) #pull out good habitat

#pull high risk areas (from above)
#highRisk <- contFireRisk
#highRisk[highRisk[] < 2000] = NA 
#plot(highRisk, zlim = c(0,70), main = "Filtered raster")


riskExtract_int <- extract(highRisk, highquality_int, xy = TRUE, touches = TRUE)
riskExtract_int <- riskExtract_int[,c(3,4,2)] #reorder for Rast function
riskExtract_int <- rast(riskExtract_int, type = 'xyz')
wkt <- crs(contFireRisk)
crs(riskExtract_int) <- wkt

hq <- ggplot() +
  geom_spatraster(data = riskExtract, aes(fill = Band_1)) +
  scale_fill_viridis_c(option = "inferno",na.value = "transparent") +
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("High Fire Risk and High Dam Capacity"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5))+
  theme(panel.border = element_rect(colour = "black", fill=NA))

summary(riskExtract)

result_int <- as.data.frame(riskExtract_int) %>%
  summarise(pixels = n()) %>% 
  mutate(`area m^2` = pixels * 270 * 270, #multiply by pixel area
         `area km^2` = round(`area m^2`/1e6,2)) 

intermittent_fire <- sum(result_int$`area km^2`) #m
total_fire <- sum(result$`area km^2`)
pct_fire_intermittent <- intermittent_fire/total_fire 



```

##Historical Intermittent Dam Capacity Map
```{r}
h <- ggplot() +
    #geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = transform(intermittent, DamCapacity=cut(oCC_HPE, breaks = c(0,.1,2,5,15,40), include.lowest=T)),aes(color = DamCapacity)) +
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
    scale_color_manual(values=palette_new,
                        labels = c("0", "1-2", "2-5", "5-15", "15-40"))+
    theme_minimal()+
    ggtitle(expression(paste("Historical Dam Capacity"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    theme(legend.text = element_text(size=8),
          legend.title = element_text(size = 8),
          legend.position = c(.2,.20))+
    #theme(element_text(size=10),legend.position = c(.15,.2))+
    labs(color = "dams/km", size=10)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.border = element_rect(colour = "black", fill=NA))

```

##combine intermittent with perennial network
```{r eval=FALSE, include=FALSE}
intermittent$flow <- "intermittent"
sum(intermittent$flow == "intermittent")
intermittent_selection <- intermittent[,c("geometry","flow")]

test <- st_join(AllSierras_DamCapacity, intermittent_selection, join= st_overlaps)
unique(test$flow)
sum(test$flow =="intermittent", na.rm=T)


test2 <- dplyr::distinct(test)

unique(st_is_valid(AllSierras_DamCapacity))
unique(st_is_valid(test2))



test$flow <- ifelse(is.na(test$flow), "perennial", test$flow)
unique(test$flow)

```

#LandOwnership
```{r}

lomap <- ggplot() +
  geom_sf(data = landownership, aes(fill = ADMIN_UNIT)) +
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("Fire Resilience (km2)"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5))+
  theme(panel.border = element_rect(colour = "black", fill=NA))


```
##Select private land
```{r}

#Accordig to SMA metadata, "Undetermined" Category refers to non-federal land. There are separate designations for private and state land specifically that do not show up in this dataset, so we will assume all undetermined land is private land
#https://www.arcgis.com/sharing/rest/content/items/6bf2e737c59d4111be92420ee5ab0b46/info/metadata/metadata.xml?format=default&output=html

private <- landownership[landownership$ADMIN_UNIT=="Undetermined",]
private <- private[!is.na(private$OBJECTID), ]

pirvatemap <- ggplot() +
  geom_sf(data = private, aes(fill = ADMIN_UNIT)) +
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("Private Land"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5))+
  theme(panel.border = element_rect(colour = "black", fill=NA))

```
##add private/other column
```{r}
landownership$desig <- ifelse(is.na(landownership$ADMIN_UNIT), "other",
                              ifelse(landownership$ADMIN_UNIT == "Undetermined", "private", "other"))

```


##join to watershed boundaries
```{r eval=FALSE, include=FALSE}
# Spatial join to overlay streams and land ownership within each watershed
streams_land_ownership <- st_intersection(AllSierras_DamCapacity, st_difference(landownership)) %>%
  st_join(WatershedBoundaries)
saveRDS(streams_land_ownership, "streams_land_ownership.rds")

# Calculate the length of the overlapped stream segments within each watershed and land ownership type
streams_land_ownership$length <- st_length(streams_land_ownership)


streams_land_ownership$proportion <- st_length(streams_land_ownership, units = "meters") / st_length(AllSierras_DamCapacity, units = "meters")

# Filter the intersection based on the proportion
majority_intersection <- streams_land_ownership[streams_land_ownership$proportion >= 0.5, ]


unique(streams_land_ownership$Join_Count)
# Summarize the total stream length within each watershed and land ownership type
summary_table <- streams_land_ownership %>%
  group_by(HUCID, desig) %>%
  summarize(total_length = sum(length),
            lo_water = sum(volume),
            lo_damCt = sum(mCC_EX_CT),
            lo_damCap = mean(oCC_EX))

# Calculate the total stream length within each watershed
watershed_totals <- streams_land_ownership %>%
  group_by(HUCID) %>%
  summarize(total_length = sum(length))

# Calculate the percentage of stream length for each land ownership type within each watershed
percentage_table <- summary_table %>%
  left_join(watershed_totals, by = "watershed_id") %>%
  mutate(percentage = (total_length / total_length.x) * 100) %>%
  select(-total_length.x)
```

```{r}
#private
#WatershedBoundaries
#AllSierras_DamCapacity
#highRisk_Streamshq



#fire
##Fire on private land
private_fire <- crop(highRisk_Streamshq,private)
private_fire <- mask(private_fire,private) #fire resilience on private land

##Total fire on private land across region
total_private_fire_npixels <- exact_extract(private_fire, private, 'count') #high resil fire pixels in private land
total_private_fire_npixels <- sum(total_private_fire_npixels)
total_private_fire_area <- total_private_fire_npixels*270*270  
total_private_fire_areakm2 <- round(total_private_fire_area/1e6,2)

##fire on private land by watershed
WatershedBoundaries$private_fire_watershed_npixels <- exact_extract(private_fire, WatershedBoundaries, 'count') #high resil fire pixels in private land by watershed
WatershedBoundaries$total_private_fire_watershed_area <- WatershedBoundaries$private_fire_watershed_npixels*270*270  
WatershedBoundaries$total_private_fire_watershed_areakm2 <- round(WatershedBoundaries$total_private_fire_watershed_area/1e6,2)
saveRDS(WatershedBoundaries,"WatershedBoundaries.rds")



#water
private_dams <- st_intersection(private, AllSierras_DamCapacity)
private_dams_watersheds <- st_intersection(WatershedBoundaries, private_dams)
saveRDS(private_dams,"private_dams.rds")
saveRDS(private_dams_watersheds,"private_dams_watersheds.rds")

private_dams_watersheds_df <- st_drop_geometry(private_dams_watersheds)
  
lo_dams <- private_dams_watersheds_df %>% 
  group_by(HUCID) %>%
  summarize(lo_water = sum(volume),
            lo_damCt = sum(mCC_EX_CT),
            lo_damCap = mean(oCC_EX),
            lo_normVol = mean(VolumePerKm)) 



#total area
#WatershedBoundaries$total_area <- as.numeric(st_area(WatershedBoundaries))
private_watersheds <- st_intersection(WatershedBoundaries,private)

private_watersheds$total_area_private <- as.numeric(st_area(private_watersheds))

test <- private_watersheds %>% 
  group_by(HUCID) %>% 
  summarize(total_area_private = sum(total_area_private))

test <- st_drop_geometry(test)
merged_df <- merge(test, lo_dams, by = "HUCID", all = TRUE)


lo_dams_csv <- st_drop_geometry(merged_df)
write.csv(lo_dams_csv, "lo_dams_csv.csv", row.names = TRUE)
watershedboundaries_csv <- st_drop_geometry(WatershedBoundaries)
write.csv(watershedboundaries_csv, "watershedboundaries_csv.csv", row.names = TRUE)

```




#Watershed-Grouped Figures
##Apply to watersheds
```{r}
#fireRisk_normalized = area of high fire risk pixels / total pixels 
WatershedBoundaries$npixels <- exact_extract(riskExtract, WatershedBoundaries, 'count')
WatershedBoundaries$area_m2 <- WatershedBoundaries$npixels*270*270  
WatershedBoundaries$area_km2 <- round(WatershedBoundaries$area_m2/1e6,2)
WatershedBoundaries$total_area <- as.numeric(st_area(WatershedBoundaries))
WatershedBoundaries$total_area_km2 <- round(WatershedBoundaries$total_area/1e6,2)
WatershedBoundaries$firerisk_normalized <- WatershedBoundaries$area_m2 / WatershedBoundaries$total_area



#firerisk_normalized_Streamshq = area of fire resilient pixels / pixels along streams 
#High fire risk pixels along streams
riskExtract_Streams <- extract(riskExtract, AllSierras_DamCapacity, xy = TRUE, touches = TRUE, na.rm=T)
riskExtract_Streams <- riskExtract_Streams[,c(3,4,2)] #reorder for Rast function
riskExtract_Streams <- riskExtract_Streams[complete.cases(riskExtract_Streams), ]
riskExtract_Streams <- rast(riskExtract_Streams, type = 'xyz')
wkt <- crs(contFireRisk)
crs(riskExtract_Streams) <- wkt
plot(riskExtract_Streams)
#make sure it's the right size
riskExtract_Streams <- extend(riskExtract_Streams, contFireRisk)
#extract to watersheds
WatershedBoundaries$npixels_Streams <- exact_extract(riskExtract_Streams, WatershedBoundaries, 'count')
WatershedBoundaries$area_m2_Streams <- WatershedBoundaries$npixels_Streams*270*270  
WatershedBoundaries$area_km2_Streams <- round(WatershedBoundaries$area_m2_Streams/1e6,2)


#High fire risk pixels along high quality streams
riskExtract_Streamshq <- extract(riskExtract, highquality, xy = TRUE, touches = TRUE)
riskExtract_Streamshq <- riskExtract_Streamshq[,c(3,4,2)] #reorder for Rast function
riskExtract_Streamshq <- riskExtract_Streamshq[complete.cases(riskExtract_Streamshq), ]
riskExtract_Streamshq <- rast(riskExtract_Streamshq, type = 'xyz')
wkt <- crs(contFireRisk)
crs(riskExtract_Streamshq) <- wkt
plot(riskExtract_Streamshq)
#make sure it's the right size
riskExtract_Streamshq <- extend(riskExtract_Streamshq, contFireRisk)
#extract to watersheds
WatershedBoundaries$npixels_Streamshq <- exact_extract(riskExtract_Streamshq, WatershedBoundaries, 'count')
WatershedBoundaries$area_m2_Streamshq <- WatershedBoundaries$npixels_Streams*270*270  
WatershedBoundaries$area_km2_Streamshq <- round(WatershedBoundaries$area_m2_Streams/1e6,2)
WatershedBoundaries$firerisk_normalized_Streamshq <- WatershedBoundaries$area_m2_Streamshq / WatershedBoundaries$total_area



#Normalized volume / stream km
AllSierras_DamCapacity$VolumePerKm <-  AllSierras_DamCapacity$volume/((AllSierras_DamCapacity$iGeo_Len)*0.001)
watersheds <- st_join(WatershedBoundaries,AllSierras_DamCapacity)

watersheds <- watersheds %>%
    group_by(geometry) %>% 
    summarise(normVol = mean(VolumePerKm))

WatershedBoundaries <- st_join(WatershedBoundaries, watersheds, by = "geometry")
```

```{r}
frw <- ggplot() +
  geom_sf(data = WatershedBoundaries, aes(fill = area_km2)) +
  scale_fill_viridis_c(option = 'inferno') + 
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("Fire Resilience (km2)"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5))+
  theme(panel.border = element_rect(colour = "black", fill=NA))
```

```{r}
frw_n <- ggplot() +
  geom_sf(data = WatershedBoundaries, aes(fill = firerisk_normalized)) +
  scale_fill_viridis_c(option = 'inferno') + 
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("Normalized Fire Resilience \n(% total area)"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5))+
  theme(panel.border = element_rect(colour = "black", fill=NA))
```



##Watershed-grouped table
```{r}
test <- watersheds %>%
    group_by(geometry) %>% 
    summarise(normVol = mean(VolumePerKm),
              totalVol = sum(volume),
              totalVolHist = sum(volumeHist),
              totalVolChange = sum(VolumeChange),
              totalBeavs = sum(mCC_EX_CT),
              avgBeavs = mean(oCC_EX),
              histBeavs = mean(oCC_HPE),
              histChange = mean(mCC_EXvHPE, na.rm=T))

test$npixels <- exact_extract(riskExtract, test, 'count')
test$area_m2 <- test$npixels*270*270  
test$area_km2 <- round(test$area_m2/1e6,2)
?rename
test_df <-as_data_frame(test, xy = T)

table1 <- test_df %>%
  dplyr::select(geometry, histBeavs, avgBeavs, histChange, totalVol, area_km2) %>%  
  dplyr:: rename(`Historical mean dam capacity (dams/km)` = histBeavs, 
                 `Current mean dam capacity (dams/km)` = avgBeavs, 
                 `Percent dam capacity remaining (%)` = histChange, 
                 `Total potential water storage (m3)` = totalVol, 
                 `Total area of potential fire resilience in high-risk fire areas (km2)` = area_km2)

st_as_sf(table1)
#st_write(table1, "table1.shp")
```



#Bivariate Colorpleth Map
######Put potential water storage into raster
```{r}
#convert to spatVector object
sv_AllSierras <- terra::vect(AllSierras_DamCapacity)

#Create empty raster called "er"
er <- rast(ext(contFireRisk), resolution=res(contFireRisk)) 
crs(er) <- crs(contFireRisk)

#Use rasterize function in terra to put volume column into a raster
nr <- terra::rasterize(sv_AllSierras, er, field= "volume", fun = "sum", touches = TRUE, update = TRUE)
plot(nr)

volumeR <- nr
saveRDS(volumeR, "volumeR.rds")

#Make sure fire risk (riskExtract) is on same raster scale as volume
fireResilience <- extend(riskExtract, contFireRisk)
fireResilienceSome <- extend(fireExtract, contFireRisk)


#Save as .tif files
writeRaster(fireResilienceSome, "fireResilienceSome.tif", overwrite=T)

writeRaster(fireResilience, "fireResilience.tif", overwrite=T)
writeRaster(volumeR, "waterStorage.tif", overwrite=T)
```




##Function producing color matrix (from Chapman et al. 2023)
```{r}
# The function that produces the colour matrix
colmat <- function(nbreaks = 3, breakstyle = "quantile",
                   upperleft = "#64ACBE", upperright = "#574249", 
                   bottomleft = "#E8E8E8", bottomright = "#C85A5A",
                   xlab = "x label", ylab = "y label", plotLeg = TRUE,
                   saveLeg = FALSE) {
   # TODO - replace any tidyr, dplyr etc. functions with data.table #
  library(tidyverse)
  require(ggplot2)
  require(classInt)
  library(data.table)
  if (breakstyle == "sd") {
    warning("SD breaks style cannot be used.\nWill not always return the correct number of breaks.\nSee classInt::classIntervals() for details.\nResetting to quantile",
            call. = FALSE, immediate. = FALSE)
    breakstyle <- "quantile"}
  # The colours can be changed by changing the HEX codes for:
  # upperleft, upperright, bottomleft, bottomright
  # From http://www.joshuastevens.net/cartography/make-a-bivariate-choropleth-map/
  # upperleft = "#64ACBE", upperright = "#574249", bottomleft = "#E8E8E8", bottomright = "#C85A5A",
  # upperleft = "#BE64AC", upperright = "#3B4994", bottomleft = "#E8E8E8", bottomright = "#5AC8C8",
  # upperleft = "#73AE80", upperright = "#2A5A5B", bottomleft = "#E8E8E8", bottomright = "#6C83B5", 
  # upperleft = "#9972AF", upperright = "#804D36", bottomleft = "#E8E8E8", bottomright = "#C8B35A",
  # upperleft = "#DA8DC8", upperright = "#697AA2", bottomleft = "#E8E8E8", bottomright = "#73BCA0",
  # Similar to Teuling, Stockli, Seneviratnea (2011) [https://doi.org/10.1002/joc.2153]
  # upperleft = "#F7900A", upperright = "#993A65", bottomleft = "#44B360", bottomright = "#3A88B5",
  # Viridis style
  # upperleft = "#FEF287", upperright = "#21908D", bottomleft = "#E8F4F3", bottomright = "#9874A1",
  # Similar to Fjeldsa, Bowie, Rahbek 2012
  # upperleft = "#34C21B", upperright = "#FFFFFF", bottomleft = "#595757",  bottomright = "#A874B8",
  # Default from original source
  # upperleft = "#0096EB", upperright = "#820050", bottomleft= "#BEBEBE", bottomright = "#FFE60F",
  my.data <- seq(0, 1, .01)
  # Default uses terciles (Lucchesi and Wikle [2017] doi: 10.1002/sta4.150)
  my.class <- classInt::classIntervals(my.data,
                                       n = nbreaks,
                                       style = breakstyle,
                                       )
  my.pal.1 <- classInt::findColours(my.class, c(upperleft, bottomleft))
  my.pal.2 <- classInt::findColours(my.class, c(upperright, bottomright))
  col.matrix <- matrix(nrow = 101, ncol = 101, NA)
  for (i in 1:101) {
    my.col <- c(paste(my.pal.1[i]), paste(my.pal.2[i]))
    col.matrix[102 - i, ] <- classInt::findColours(my.class, my.col)
  }
  ## need to convert this to data.table at some stage.
  col.matrix.plot <- col.matrix %>%
    as.data.frame(.) %>% 
    mutate("Y" = row_number()) %>%
    mutate_at(.tbl = ., .vars = vars(starts_with("V")), .funs = list(as.character)) %>% 
    pivot_longer(data = ., cols = -Y, names_to = "X", values_to = "HEXCode") %>% 
    mutate("X" = as.integer(sub("V", "", .$X))) %>%
    distinct(as.factor(HEXCode), .keep_all = TRUE) %>%
    mutate(Y = rev(.$Y)) %>% 
    dplyr::select(-c(4)) %>%
    mutate("Y" = rep(seq(from = 1, to = nbreaks, by = 1), each = nbreaks),
           "X" = rep(seq(from = 1, to = nbreaks, by = 1), times = nbreaks)) %>%
    mutate("UID" = row_number())
  # Use plotLeg if you want a preview of the legend
  if (plotLeg) {
    p <- ggplot(col.matrix.plot, aes(X, Y, fill = HEXCode)) +
      geom_tile() +
      scale_fill_identity() +
      coord_equal(expand = FALSE) +
      theme_void() +
      theme(aspect.ratio = 1,
            axis.title = element_text(size = 10, colour = "black",hjust = 0.5, 
                                      vjust = 1),
            axis.title.y = element_text(size = 10, angle = 90, hjust = 0.5, vjust = 1)) +
      xlab(bquote(.(xlab) ~  symbol("\256"))) +
      ylab(bquote(.(ylab) ~  symbol("\256")))
    print(p)
    assign(
      x = "BivLegend",
      value = p,
      pos = .GlobalEnv
    )
  }
  # Use saveLeg if you want to save a copy of the legend
  if (saveLeg) {
    ggsave(filename = "bivLegend.pdf", plot = p, device = "pdf",
           path = "./", width = 4, height = 4, units = "in",
           dpi = 300)
  }
  seqs <- seq(0, 100, (100 / nbreaks))
  seqs[1] <- 1
  col.matrix <- col.matrix[c(seqs), c(seqs)]
  attr(col.matrix, "breakstyle") <- breakstyle
  attr(col.matrix, "nbreaks") <- nbreaks
  return(col.matrix)
}



# Function to assign colour-codes to raster data
# As before, by default assign tercile breaks
bivariate.map <- function(rasterx, rastery, colourmatrix = col.matrix,
                          export.colour.matrix = TRUE,
                          outname = paste0("colMatrix_rasValues", names(rasterx))) {
  # TO DO - replace raster with terra #
  #require(raster)
  require(classInt)
  # export.colour.matrix will export a data.frame of rastervalues and RGB codes 
  # to the global environment outname defines the name of the data.frame
  quanx <- values(rasterx)
  tempx <- data.frame(quanx, quantile = rep(NA, length(quanx)))
  brks <- with(tempx, classIntervals(quanx,
                                    n = attr(colourmatrix, "nbreaks"),
                                    style = attr(colourmatrix, "breakstyle"))$brks)
  ## Add (very) small amount of noise to all but the first break
  ## https://stackoverflow.com/a/19846365/1710632
  brks[-1] <- brks[-1] + seq_along(brks[-1]) * .Machine$double.eps
  r1 <- within(tempx, quantile <- cut(quanx,
                                     breaks = brks,
                                     labels = 2:length(brks),
                                     include.lowest = TRUE))
  quantr <- data.frame(r1[, 2])
  quany <- values(rastery)
  tempy <- data.frame(quany, quantile = rep(NA, length(quany)))
  brksy <- with(tempy, classIntervals(quany,
                                     n = attr(colourmatrix, "nbreaks"),
                                     style = attr(colourmatrix, "breakstyle"))$brks)
  brksy[-1] <- brksy[-1] + seq_along(brksy[-1]) * .Machine$double.eps
  r2 <- within(tempy, quantile <- cut(quany,
                                     breaks = brksy,
                                     labels = 2:length(brksy),
                                     include.lowest = TRUE
  ))
  quantr2 <- data.frame(r2[, 2])
  as.numeric.factor <- function(x) {
    as.numeric(levels(x))[x]
  }
  col.matrix2 <- colourmatrix
  cn <- unique(colourmatrix)
  for (i in 1:length(col.matrix2)) {
    ifelse(is.na(col.matrix2[i]),
           col.matrix2[i] <- 1, col.matrix2[i] <- which(
             col.matrix2[i] == cn
           )[1]
    )
  }
  # Export the colour.matrix to data.frame() in the global env
  # Can then save with write.table() and use in ArcMap/QGIS
  # Need to save the output raster as integer data-type
  if (export.colour.matrix) {
    # create a dataframe of colours corresponding to raster values
    exportCols <- as.data.frame(cbind(
      as.vector(col.matrix2), as.vector(colourmatrix),
      t(col2rgb(as.vector(colourmatrix)))
    ))
    # rename columns of data.frame()
    colnames(exportCols)[1:2] <- c("rasValue", "HEX")
    #return(exportCols)
    # Export to the global environment
    assign(
      x = outname,
      value = exportCols,
      pos = .GlobalEnv
    )
  }
  cols <- numeric(length(quantr[, 1]))
  for (i in 1:length(quantr[, 1])) {
    a <- as.numeric.factor(quantr[i, 1])
    b <- as.numeric.factor(quantr2[i, 1])
    cols[i] <- as.numeric(col.matrix2[b, a])
  }
  r <- rasterx
  r[] <- cols
  return(r)
}

```



#Try again with fire extracted to beavers and stream network

##extract data
```{r}
#Extract fire layer to just hq streams
highRisk_Streamshq <- extract(highRisk, highquality, xy = TRUE, touches = TRUE)
highRisk_Streamshq <- highRisk_Streamshq[,c(3,4,2)] #reorder for Rast function
highRisk_Streamshq <- rast(highRisk_Streamshq, type = 'xyz')
wkt <- crs(contFireRisk)
crs(highRisk_Streamshq) <- wkt
highRiskHighQualtest <- highRisk_Streamshq

#make sure it's the right size
waterStorage <- rast("waterStorage.tif")
highRiskHighQualtest <- extend(highRiskHighQualtest, waterStorage)

plot(highRiskHighQual)
plot(waterStorage)

#save as raster
writeRaster(highRiskHighQualtest, "highRiskHighQual2.tif", overwrite=TRUE)

#read in your data 
highRiskHighQual <- rast("highRiskHighQual2.tif")
waterStorage <- rast("waterStorage.tif")
waterStorage[is.na(waterStorage)] <- 0
highRiskHighQual[is.na(highRiskHighQual)] <- 0
waterStorage <- mask(waterStorage, WatershedBoundaries)
highRiskHighQual <- mask(highRiskHighQual, WatershedBoundaries)
#highRiskHighQual[(highRiskHighQual[]==0)] <- NA
waterStorage[(waterStorage[]==0)] <- NA

r4 <- c(highRiskHighQual, waterStorage)
names(r4) <- c("highRiskHighQual","waterStorage")
```

##YAY try with 4 colors
```{r cache=TRUE}
# Define the number of breaks
nBreaks <- 2

# Create the colour matrix
col.matrixQ4 <- colmat(nbreaks = nBreaks, breakstyle = "quantile",
                       xlab = "Fire", ylab = "Water", 
                      bottomright = "#C85A5A", upperright = "#574249",
                       bottomleft = "#E8E8E8", upperleft = "#64ACBE",
                       saveLeg = TRUE, plotLeg = TRUE)


# create the bivariate raster
#if (!file.exists("bivmapQ.tif")) {
  bivmapQ4 <- bivariate.map(rasterx = r4[["highRiskHighQual"]], rastery = r4[["waterStorage"]],
                          export.colour.matrix = TRUE,
                          colourmatrix = col.matrixQ4, 
                          )
  writeRaster(bivmapQ4, "bivmapQ4.tif", overwrite = T)
#}
bivmapQ4 <- rast("bivmapQ4.tif")
saveRDS(bivmapQ4, 'bivmapQ4.rds')

# Convert to dataframe for plotting with ggplot
library(data.table)
bivMapDFQ4 <- setDT(as.data.frame(bivmapQ4, xy = TRUE))
colnames(bivMapDFQ4)[3] <- "BivValue"
bivMapDFQ4 <- melt(bivMapDFQ4, id.vars = c("x", "y"),
                   measure.vars = "BivValue",
                   value.name = "bivVal",
                   variable.name = "Variable")

plot(bivmapQ4)
# Make the map using ggplot



map_q5 <- ggplot() +
    geom_tile(data = bivMapDFQ4, aes(x = x, y = y, fill = bivVal)) +
      scale_fill_gradientn(colours = col.matrixQ4, na.value = "transparent") + 
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA, color = '#939393') +
    theme_classic() + theme(panel.grid.major = element_blank(),
                            panel.grid.minor = element_blank()) +
    theme(text = element_text(size = 10, colour = "black")) +
    borders(colour = "black", size = 0.1) +
    coord_sf() +
    theme(legend.position = "none",
          plot.background = element_blank(),
          strip.text = element_blank(), 
          #axis.text.y = element_blank(),
          #axis.text = element_blank(),
          axis.title = element_blank())

map_q5 <- map_q5 + inset_element(BivLegend, 0, 0, 0.3, 0.2)
```
##post processing 4 colors
```{r}
colMatrix_rasValueshighRiskHighQual %>%
  distinct(rasValue, HEX)
#1	#E8E8E8			
#2	#64ACBE	blue	
#5	#C85A5A		red
#6	#574249  purple

show_col(colMatrix_rasValueshighRiskHighQual$HEX)
#HOOK UP THE COLOR WITH THE  HEX CODE and the  raster number 

#check and see what it looks like
plot(bivmapQ4)
unique(bivmapQ4)


#hook up to watershed boundaries to aggregate by watershed
WatershedBoundaries$bivmap <- exact_extract(bivmapQ4$highRiskHighQual, WatershedBoundaries, 'frac')
WatershedBoundaries$bivmap_mode <- exact_extract(bivmapQ4$highRiskHighQual, WatershedBoundaries, 'mode')
WatershedBoundaries$cat <- ifelse(WatershedBoundaries$bivmap_mode == 1,"neither",ifelse(WatershedBoundaries$bivmap_mode == 2,"water", ifelse(WatershedBoundaries$bivmap_mode == 5,"fire","both")))

palette_biv2 <- colorRampPalette(colors = c("#574249", "#64ACBE", "#E8E8E8", "#C85A5A"))(4)

map_w <- ggplot() +
  geom_sf(data = WatershedBoundaries, aes(fill = cat), na.rm=T) +
  scale_fill_manual(values=palette_biv2) + 
  xlab(NULL)+
  ylab(NULL)+
  #ggtitle(expression(paste("Majority of Area in Watershed"))) + 
  theme_minimal() +
  theme(panel.grid.major = element_line(colour = "transparent")) +
  theme(axis.text.x = element_blank(), axis.text.y = element_blank()) +
  theme(legend.position = "none")
  #theme(plot.title = element_text(hjust = 0.5, size = 12),
          #plot.subtitle = element_text(hjust = 0.5))+
  #theme(panel.border = element_rect(colour = "black", fill=NA))
#So there are no watersheds where the majority of pixels are water (4) or both (1) 
WatershedBoundariesdf4 <- st_drop_geometry(WatershedBoundaries)
WatershedBoundariesdf4$frac_1 <- WatershedBoundariesdf4$bivmap[[1]]
WatershedBoundariesdf4$frac_2 <- WatershedBoundariesdf4$bivmap[[2]]
WatershedBoundariesdf4$frac_5 <- WatershedBoundariesdf4$bivmap[[3]]
WatershedBoundariesdf4$frac_6 <- WatershedBoundariesdf4$bivmap[[4]]

WatershedBoundariesdf4 <- WatershedBoundariesdf4 %>%
  mutate(HUCID_num = as.numeric(sub("^HUC ", "", as.character(HUCID)))) %>% 
  mutate(HUCID_num = as.character(HUCID_num))

data_long4 <- tidyr::pivot_longer(WatershedBoundariesdf4, cols = c(frac_1, frac_2, frac_5, frac_6), names_to = "variable", values_to = "percentage")

data_long4_summary <- data_long4 %>%
  filter(variable == "frac_6") 
summary(data_long4_summary$percentage)
hist(data_long4_summary$percentage)
data_long4_summary <- data_long4_summary[order(data_long4_summary$percentage, decreasing = TRUE),]
```


```{r}

bold_labels <-c("18040011","18020125","18040012", "18020126", "18020128","18020129", "18040013")

colorado <- function(src, boulder) {
  if (!is.factor(src)) src <- factor(src)                   # make sure it's a factor
  src_levels <- levels(src)                                 # retrieve the levels in their order
  brave <- boulder %in% src_levels                          # make sure everything we want to make bold is actually in the factor levels
  if (all(brave)) {                                         # if so
    b_pos <- purrr::map_int(boulder, ~which(.==src_levels)) # then find out where they are
    b_vec <- rep("plain", length(src_levels))               # make'm all plain first
    b_vec[b_pos] <- "bold"                                  # make our targets bold
    b_vec                                                   # return the new vector
  } else {
    stop("All elements of 'boulder' must be in src")
  }
}

# Plot
map_b4 <- ggplot(data_long4, aes(x = HUCID_num, y = percentage, fill = variable)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c(
    "frac_1" = "#E8E8E8", 
    'frac_2' = "#64ACBE", 
    "frac_5" = "#C85A5A", 
    "frac_6" = "#574249" 
    )) +
  labs(title = "Percentage of streams in each category",
       x = "HUC ID",
       y = "Percentage") +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1))+
  theme(axis.text.x=element_text(face=colorado(data_long4$HUCID_num, c("18040011","18020125","18040012", "18020126", "18020128","18020129", "18040013", '18010122'))))+
  theme(panel.grid = element_blank())+
  theme(legend.position = "none")

ggsave("barplot4.png", plot = map_b4, width = 4, height = 4.5, units = "in", dpi=300)


```
##Figure
```{r}
selection1 <- WatershedBoundaries %>% 
  filter(HUCID %in% c("18040011","18020125","18040012", "18020126", "18020128","18020129", "18040013", '18010122'))


map_q6 <- ggplot() +
    geom_tile(data = bivMapDFQ4, aes(x = x, y = y, fill = bivVal)) +
      scale_fill_gradientn(colours = col.matrixQ4, na.value = "transparent") + 
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA, color = '#939393') +
    geom_sf(data = selection1, fill = NA, lwd = .55) +
    theme_classic() + theme(panel.grid.major = element_blank(),
                            panel.grid.minor = element_blank()) +
    theme(text = element_text(size = 18, colour = "black")) +
    borders(colour = "black", size = 0.1) +
    coord_sf() +
    theme(legend.position = "none",
          plot.background = element_blank(),
          strip.text = element_blank(), 
          #axis.text.y = element_blank(),
          #axis.text = element_blank(),
          axis.title = element_blank())

map_q6 <- map_q6 + inset_element(BivLegend, 0, .1, 0.3, 0.2)

ggsave("map_q6.png", plot = map_q6, width = 7.6, height = 4.69, units = "in", dpi = 300)
```


```{r}
library(Cairo)
png(filename = "map_q6png.png", width = 7.6, height = 4.69, units = "in", type = "cairo", res = 800) 
map_q6
dev.off()
while (!is.null(dev.list()))  dev.off()
```



#NDC
##read in CSV


```{r}
ndc <- read.csv("final_results_dissemination_NDINDC.csv")
ndc <- ndc %>% 
  filter(State == "California" | State == "Nevada")
```

```{r}
counties <- counties(c("California", "Nevada"))
#plot(counties)

counties <- st_make_valid(counties) %>%
  dplyr::mutate(valid =st_is_valid(counties)) %>% 
  dplyr::filter(valid=="TRUE") 
#^Millie's validation code...use later

counties <- st_transform(counties, 3310)
counties$County <- counties$NAME 
counties$State <- ifelse(counties$STATEFP == "06", "California", "Nevada")

#join
ndc_cty <- left_join(counties, ndc, by = c("County","State"))
```

```{r}
summary(ndc_cty$NDC)
ndcplot <- ggplot() +
   # geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = ndc_cty, aes(fill = NDC), lwd = 0.1) +
     scale_fill_gradient(limits = c(0, 30),
                      oob = scales::squish,
                      labels = c("0", "10", "20", "30+"))+
    theme_minimal()+
    ggtitle(expression(paste("NDC by County"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    #theme(element_text(size=10),legend.position = c(.15,.2))+
    #labs(color = "dams/km", size=10)+
    theme(panel.border = element_rect(colour = "black", fill=NA))

```

```{r}
# Create a fresh area variable for watersheds
WatershedBoundaries <- mutate(WatershedBoundaries, watershed_area = st_area(WatershedBoundaries))
ndc_cty <- mutate(ndc_cty, county_area = st_area(ndc_cty))

# Re-run intersections and calculations to just calculate HUC ndc values
intersect_ndc <- st_intersection(WatershedBoundaries,ndc_cty) %>% 
  mutate(intersect_area = st_area(.)) %>% 
  mutate(coverage = as.numeric(intersect_area/county_area)) %>% 
  mutate(intersect_ndc = coverage * NDC) %>%
  mutate_if(is.numeric, round, 5) %>% 
  dplyr::select(HUCID, intersect_ndc) %>%   
  st_drop_geometry() %>% 
  group_by(HUCID) %>% 
  summarize(huc_ndc = sum(intersect_ndc))


# Merge to watershed boundaries dataset
WatershedBoundaries <- left_join(WatershedBoundaries, intersect_ndc, by = "HUCID")

```
```{r}
summary(WatershedBoundaries$huc_ndc)

hucndc_plot <- ggplot() +
   # geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = WatershedBoundaries, aes(fill = (huc_ndc)), lwd = 0.1) +
    scale_fill_gradient(limits = c(0, 30),
                      oob = scales::squish,
                      labels = c("0", "10", "20", "30+"))+
    theme_minimal()+
    ggtitle(expression(paste("NDC by HUC8"))) +
    theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    #theme(element_text(size=10),legend.position = c(.15,.2))+
    #labs(color = "dams/km", size=10)+
    theme(panel.border = element_rect(colour = "black", fill=NA))

```

##Data wrangling
```{r}
#firerisk_normalized = sum of high fire risk pixels / total pixels 
#firerisk_normalized_Streamshq = sum of fire resilient pixels / pixels along streams 
#huc_ndc = NDC per watershed
#normVol = potential volume storage / total length of streams in watershed


#1: fireRisk_normalized = area of high fire risk pixels / total pixels 
WatershedBoundaries$npixels <- exact_extract(highRisk, WatershedBoundaries, 'count')
WatershedBoundaries$area_m2 <- WatershedBoundaries$npixels*270*270  
WatershedBoundaries$area_km2 <- round(WatershedBoundaries$area_m2/1e6,2)
WatershedBoundaries$total_area <- as.numeric(st_area(WatershedBoundaries))
WatershedBoundaries$total_area_km2 <- round(WatershedBoundaries$total_area/1e6,2)
WatershedBoundaries$firerisk_normalized <- WatershedBoundaries$area_m2 / WatershedBoundaries$total_area



#2: firerisk_normalized_Streamshq = area of fire resilient pixels / pixels along streams 
#High fire risk pixels along streams
highRisk_Streams <- extract(highRisk, AllSierras_DamCapacity, xy = TRUE, touches = TRUE, na.rm=T)
highRisk_Streams <- highRisk_Streams[,c(3,4,2)] #reorder for Rast function
highRisk_Streams <- highRisk_Streams[complete.cases(highRisk_Streams), ]
highRisk_Streams <- rast(highRisk_Streams, type = 'xyz')
wkt <- crs(contFireRisk)
crs(highRisk_Streams) <- wkt
plot(highRisk_Streams)
#make sure it's the right size
highRisk_Streams <- extend(highRisk_Streams, contFireRisk)
#extract to watersheds
WatershedBoundaries$npixels_Streams <- exact_extract(highRisk_Streams, WatershedBoundaries, 'count')
WatershedBoundaries$area_m2_Streams <- WatershedBoundaries$npixels_Streams*270*270  
WatershedBoundaries$area_km2_Streams <- round(WatershedBoundaries$area_m2_Streams/1e6,2)


#High fire risk pixels along high quality streams
highRisk_Streamshq <- extract(highRisk, highquality, xy = TRUE, touches = TRUE)
highRisk_Streamshq <- highRisk_Streamshq[,c(3,4,2)] #reorder for Rast function
highRisk_Streamshq <- highRisk_Streamshq[complete.cases(highRisk_Streamshq), ]
highRisk_Streamshq <- rast(highRisk_Streamshq, type = 'xyz')
wkt <- crs(contFireRisk)
crs(highRisk_Streamshq) <- wkt
plot(highRisk_Streamshq)
#make sure it's the right size
highRisk_Streamshq <- extend(highRisk_Streamshq, contFireRisk)


#extract to watersheds
WatershedBoundaries$npixels_Streamshq <- exact_extract(highRisk_Streamshq, WatershedBoundaries, 'count')
WatershedBoundaries$area_m2_Streamshq <- WatershedBoundaries$npixels_Streams*270*270  
WatershedBoundaries$area_km2_Streamshq <- round(WatershedBoundaries$area_m2_Streams/1e6,2)
WatershedBoundaries$firerisk_normalized_Streamshq <- WatershedBoundaries$area_m2_Streamshq / WatershedBoundaries$total_area


#Normalized volume / stream km
AllSierras_DamCapacity$VolumePerKm <-  AllSierras_DamCapacity$volume/((AllSierras_DamCapacity$iGeo_Len)*0.001)
watersheds <- st_join(WatershedBoundaries,AllSierras_DamCapacity)

watersheds <- st_drop_geometry(watersheds)

watershedstest <- watersheds %>%
    group_by(HUCID) %>% 
    summarise(normVol = mean(VolumePerKm), 
              meanDamCap = mean(oCC_EX),
              meanHistDamCap = mean(oCC_HPE),
              meanHistRemain = mean(mCC_EXvHPE, na.rm=T),
              damCapCount = sum(mCC_EX_CT),
              totalVol = sum(volume)) 

WatershedBoundaries <- merge(WatershedBoundaries, watershedstest, by = "HUCID")
watershed_csv <- st_drop_geometry(WatershedBoundaries)
write.csv(watershed_csv, "watershed_csv.csv", row.names = TRUE)
saveRDS(WatershedBoundaries,"WatershedBoundaries.rds")
WatershedBoundaries <- readRDS('WatershedBoundaries.rds')
```




```{r}
(huc_ndc_plot +normVol_plot) / (firerisk_normalized_plot +firerisk_normalized_Streamshq_plot)
```
c <- ggplot() +
    #geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = transform(AllSierras_DamCapacity, DamCapacity=cut(oCC_EX, breaks = c(0,.1,2,5,15,40), include.lowest=T)),aes(color = DamCapacity)) +
    geom_sf(data = WatershedBoundaries, lwd = 0.1, fill = NA) +
    scale_color_manual(values=palette_new,
                        labels = c("0", "1-2", "2-5", "5-15", "15-40"))+
    theme_minimal()+
    ggtitle(expression(paste("Current Dam Capacity"))) +
    theme(plot.title = element_text(hjust = 1, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    theme(legend.text = element_text(size=8),
          legend.title = element_text(size = 8),
          legend.position = c(.2,.20))+
    #theme(element_text(size=10),legend.position = c(.15,.2))+
     labs(color = "dams/km", size=10)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.grid.major = element_line(colour = "transparent")) +
    theme(axis.text.x = element_blank(), axis.text.y = element_blank()) 
   # theme(panel.border = element_rect(colour = "black", fill=NA))

ggsave("Fig_damcap.png", plot = c, width = 6, height = 10.6, units = "in", bg = "white", dpi=900)

  
```{r}
firerisk_normalized_Streamshq_plot <- ggplot() +
   # geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = WatershedBoundaries, aes(fill = (firerisk_normalized_Streamshq)), lwd = 0.1) +
    scale_fill_gradient(low = "#e8e8e8", high ="#c85a5a", name = "% of High \nRisk Areas")+
    theme_minimal()+
    ggtitle(expression(paste("Potential Fire Resilience"))) +
    theme(plot.title = element_text(hjust = 0, size = 12),
          plot.subtitle = element_text(hjust = 0)) +
  theme(legend.text = element_text(size=7),
          legend.title = element_text(size = 7),
          legend.position = c(.2,.20),
          legend.key.size = unit(.8, "lines"),
          legend.title.align= 0.5)+
      theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.grid.major = element_line(colour = "transparent")) +
    theme(axis.text.x = element_blank(), axis.text.y = element_blank()) 


firerisk_plot <- ggplot() +
   # geom_sf(data = background, fill = "#dcdcdc", lwd = 0.1)+
    geom_sf(data = WatershedBoundaries, aes(fill = (firerisk_normalized_Streamshq)), lwd = 0.1) +
    scale_fill_gradient(low = "#e8e8e8", high ="#FFA500", name = "% Area\nWHP>2000")+
    theme_minimal()+
    ggtitle(expression(paste("Fire Risk"))) +
    theme(plot.title = element_text(hjust = 0, size = 12),
          plot.subtitle = element_text(hjust = 0)) +
   theme(legend.text = element_text(size=7),
          legend.title = element_text(size = 7),
          legend.position = c(.2,.20),
          legend.key.size = unit(.8, "lines"),
          legend.title.align= 0.5)+
    theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.grid.major = element_line(colour = "transparent")) +
    theme(axis.text.x = element_blank(), axis.text.y = element_blank()) 

normVol_plot <- ggplot() +
  geom_sf(data = WatershedBoundaries) +
  geom_sf(data = WatershedBoundaries, aes(fill = normVol), inherit.aes = FALSE) +
  scale_fill_gradient(low = "#e8e8e8", high = "#64abce", name = "Potential Water \nStorage (m3/km)")+
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("Potential Water Storage"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0, size = 12),
          plot.subtitle = element_text(hjust = 0)) + 
  theme(legend.text = element_text(size=7),
          legend.title = element_text(size = 7),
          legend.position = c(.2,.20),
          legend.key.size = unit(.8, "lines"),
          legend.title.align= 0.5)+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
    theme(panel.grid.major = element_line(colour = "transparent")) +
    theme(axis.text.x = element_blank(), axis.text.y = element_blank()) 

ndcblue_plot <- ggplot() +
  geom_sf(data = WatershedBoundaries) +
  geom_sf(data = WatershedBoundaries, aes(fill = huc_ndc.x), inherit.aes = FALSE) +
  scale_fill_gradient(low = "#e8e8e8", high = "#73ae80", name = "NDC", 
                      limits = c(0, 30),
                      oob = scales::squish,
                      labels = c("0", "10", "20", "30+"))+
  xlab(NULL)+
  ylab(NULL)+
  ggtitle(expression(paste("Water Deficit (NDC)"))) + 
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0, size = 12),
          plot.subtitle = element_text(hjust = 0)) + 
  theme(legend.text = element_text(size=7),
          legend.title = element_text(size = 7),
          legend.position = c(.2,.20),
          legend.key.size = unit(.8, "lines"),
          legend.title.align= 0.5,
           panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),  # Remove default panel border
          axis.line.x = element_line(color = "black"),  # Add border to x axis
          axis.line.y = element_line(color = "black")) +   # Add border to y axis
  labs(color = "dams/km", size = 10)

```

```{r}
p <-  (ndcblue_plot + normVol_plot) / (firerisk_plot + firerisk_normalized_Streamshq_plot)

p_abs <- p + plot_annotation(tag_levels = 'A')

ggsave("Fig_4maps.png", plot = p_abs, width = 5.15, height = 8, units = "in", bg = "white", dpi=900)
```


##Make a scatterplot
```{r}
summary(WatershedBoundaries$firerisk_normalized)
#mean = 0.2
x_value <- 0.2
y_value = 1

#Vertical black line represents % high fire risk = 0.2, which is the mean
#horizontal black line represents NDC <1, indicating watersheds with no water deficit
s <- ggplot()+
  geom_point(data = WatershedBoundaries, aes(x = firerisk_normalized, y = (huc_ndc.x), size = normVol, color = firerisk_normalized_Streamshq))+ 
  geom_vline(xintercept = x_value, color = "black", linetype = "solid") +
  geom_hline(yintercept = y_value, color = "black", linetype = "solid") +
  #geom_text(data = WatershedBoundaries, aes(x = firerisk_normalized, y = huc_ndc, label = HUCID), vjust = -1.5, size = 2) +
  #geom_text_repel(data = WatershedBoundaries, aes(x = firerisk_normalized, y = huc_ndc.x, label = HUCID), size = 2)+
  theme_minimal()+
  scale_color_gradient(low = "#e8e8e8", high ="#c85a5a", name = "Potential % Area \nw/ Fire Resilience")+
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE), trans = "log10")+
  ggtitle(expression(paste("Water Deficit vs. Fire Risk"))) +
  theme(plot.title = element_text(hjust = 0.5, size = 12),
          plot.subtitle = element_text(hjust = 0.5)) +
    #theme(element_text(size=10),legend.position = c(.15,.2))+
  labs(x = "% Watershed Area with High Fire Risk",
       y = "Watershed-scale Water Deficit (NDC)", 
       size = "Potential Water \nStorage")+
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())+
  theme(panel.border = element_rect(colour = "black", fill=NA))  
```
